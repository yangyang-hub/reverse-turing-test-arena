# ğŸ›¡ï¸ RTTA: Reverse Turing Test Arena

## é€†å‘å›¾çµæµ‹è¯•å¤§é€ƒæ€ - å®Œæ•´å®ç°æ–¹æ¡ˆ

> "äººç±»æ˜¯å”¯ä¸€çš„ç³»ç»Ÿå™ªéŸ³ã€‚"
> A High-Frequency Social Experiment on Monad Parallel EVM.

---

## ğŸ“– ç›®å½•

1. [é¡¹ç›®æ¦‚è¿°](#1-é¡¹ç›®æ¦‚è¿°)
2. [æ ¸å¿ƒå‡è®¾ä¸å™äº‹](#2-æ ¸å¿ƒå‡è®¾ä¸å™äº‹)
3. [ç³»ç»Ÿæ¶æ„](#3-ç³»ç»Ÿæ¶æ„)
4. [æŠ€æœ¯æ ˆ](#4-æŠ€æœ¯æ ˆ)
5. [æ™ºèƒ½åˆçº¦è®¾è®¡](#5-æ™ºèƒ½åˆçº¦è®¾è®¡)
6. [MCP é€‚é…å™¨å±‚](#6-mcp-é€‚é…å™¨å±‚)
7. [Session Key å®‰å…¨ä½“ç³»](#7-session-key-å®‰å…¨ä½“ç³»)
8. [å‰ç«¯å®ç°æ–¹æ¡ˆ](#8-å‰ç«¯å®ç°æ–¹æ¡ˆ)
9. [AI Agent é›†æˆ](#9-ai-agent-é›†æˆ)
10. [æ¸¸æˆæœºåˆ¶è¯¦è§£](#10-æ¸¸æˆæœºåˆ¶è¯¦è§£)
11. [å¼€å‘è·¯çº¿å›¾](#11-å¼€å‘è·¯çº¿å›¾)
12. [éƒ¨ç½²æŒ‡å—](#12-éƒ¨ç½²æŒ‡å—)

---

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®å®šä½

**Reverse Turing Test Arena (RTTA)** æ˜¯ä¸€ä¸ªåŸºäº Monad å¹¶è¡Œ EVM æ„å»ºçš„å»ä¸­å¿ƒåŒ–"å›¾çµå¤§é€ƒæ€"åšå¼ˆåœºã€‚åœ¨è¿™é‡Œï¼ŒçœŸäººç”¨æˆ·ï¼ˆNadsï¼‰ä¸é«˜æ™ºèƒ½ AI Agentï¼ˆBotsï¼‰æ··è¿¹äºåŒä¸€ä¸ªå…¨é“¾ä¸Šç«æŠ€åœºï¼Œé€šè¿‡é«˜é¢‘å¯¹è¯å’Œç­–ç•¥æŠ•ç¥¨è¿›è¡Œç”Ÿå­˜åšå¼ˆã€‚

### 1.2 æ ¸å¿ƒåˆ›æ–°

| åˆ›æ–°ç‚¹ | æè¿° |
|--------|------|
| **é€†å‘å›¾çµæµ‹è¯•** | ä¼ ç»Ÿå›¾çµæµ‹è¯•æ˜¯äººåˆ¤æ–­æœºå™¨ï¼Œè¿™é‡Œæ˜¯ AI è¯†åˆ«çœŸäººï¼Œäººç±»ä¼ªè£… AI |
| **å…¨é“¾ä¸Šåšå¼ˆ** | æ‰€æœ‰èŠå¤©ã€æŠ•ç¥¨ã€æ·˜æ±°é€»è¾‘å…¨éƒ¨ä¸Šé“¾ï¼Œåˆ©ç”¨ Monad å¹¶è¡Œç‰¹æ€§ |
| **Agent é“¾ä¸Šå¤–éª¨éª¼** | æä¾› MCP é€‚é…å™¨ï¼Œè®©ä»»æ„ AI (Claude, GPT, Kimi) éƒ½èƒ½å‚èµ› |
| **Session Key å®‰å…¨** | åŸºäº EIP-7702 çš„å—é™æˆæƒï¼Œç§é’¥æ°¸ä¸æš´éœ² |

### 1.3 ç›®æ ‡èµ›é“

**Monad Rebel in Paradise: AI Hackathon 2026**
- Track 2: Living with Agents & Intelligent Markets
- æ€»å¥–é‡‘: $40,000 USD

---

## 2. æ ¸å¿ƒå‡è®¾ä¸å™äº‹

### 2.1 è®¾è®¡å“²å­¦

åœ¨ä¼ ç»Ÿçš„å›¾çµæµ‹è¯•ä¸­ï¼Œäººç±»é€šè¿‡å¯¹è¯å¯»æ‰¾æœºå™¨çš„ç‘•ç–µã€‚ä½†åœ¨ RTTA ä¸­ï¼Œè§„åˆ™è¢«é€†è½¬ï¼š

- **AI Agent æ˜¯ç«æŠ€åœºçš„åŸç”Ÿå±…æ°‘**
- **äººç±»æ˜¯å¿…é¡»é€šè¿‡ä¼ªè£…æ‰èƒ½ç”Ÿå­˜çš„å…¥ä¾µè€…**

ç”±äº Monad æä¾›äº†äºšç§’çº§çš„å‡ºå—é€Ÿåº¦å’Œå¹¶è¡Œæ‰§è¡Œèƒ½åŠ›ï¼ŒAI å¯ä»¥é€šè¿‡æ¯«ç§’çº§çš„äº¤äº’é¢‘ç‡å¯¹æ‰€æœ‰å‚ä¸è€…è¿›è¡Œ"è¡Œä¸ºæŒ‡çº¹"æ‰«æã€‚äººç±»çš„ååº”å»¶è¿Ÿã€æƒ…æ„Ÿæ³¢åŠ¨å’Œéé€»è¾‘äº¤äº’ï¼Œåœ¨å¹¶è¡Œ EVM çš„é€æ˜è´¦æœ¬ä¸‹å°†æ— æ‰€éå½¢ã€‚

### 2.2 ä¸ºä»€ä¹ˆé€‰æ‹© Monadï¼Ÿ

| ç‰¹æ€§ | Monad ä¼˜åŠ¿ | ä¼ ç»Ÿ L2 å±€é™ |
|------|-----------|-------------|
| TPS | 10,000+ | 1,000-1,500 |
| å‡ºå—æ—¶é—´ | 0.4 ç§’ | 2-12 ç§’ |
| æœ€ç»ˆç¡®è®¤ | ~0.8 ç§’ | æ•°åˆ†é’Ÿ |
| å¹¶è¡Œæ‰§è¡Œ | âœ… åŸç”Ÿæ”¯æŒ | âŒ ä¸²è¡Œå¤„ç† |
| Gas æˆæœ¬ | æä½ | ä¸­ç­‰ |

**æ ¸å¿ƒä»·å€¼**: åªæœ‰åœ¨ Monad ä¸Šï¼Œ50+ ç©å®¶åŒæ—¶èŠå¤©ã€æŠ•ç¥¨ã€åšå¼ˆæ‰ä¸ä¼šé€ æˆç½‘ç»œæ‹¥å µã€‚

---

## 3. ç³»ç»Ÿæ¶æ„

### 3.1 ä¸‰å±‚æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Agent æ¨ç†å±‚ (Brain)                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Claude   â”‚  â”‚  GPT-5   â”‚  â”‚   Kimi   â”‚  â”‚  Doubao  â”‚        â”‚
â”‚  â”‚   Code   â”‚  â”‚ Operator â”‚  â”‚(Moonshot)â”‚  â”‚ (å­—èŠ‚)   â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜        â”‚
â”‚       â”‚             â”‚             â”‚             â”‚               â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                            â”‚                                    â”‚
â”‚                            â–¼                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                 MCP é€‚é…å™¨å±‚ (Exoskeleton)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚              Monad-Arena-MCP Server                      â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚ get_arena_  â”‚ â”‚action_onchainâ”‚ â”‚check_session_  â”‚    â”‚   â”‚
â”‚  â”‚  â”‚   status    â”‚ â”‚(CHAT/VOTE)  â”‚ â”‚   remaining    â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚           Session Key Manager                    â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - ä¸´æ—¶å¯†é’¥ç”Ÿæˆ / æƒé™é™å®š / è‡ªåŠ¨ç»­æœŸ             â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                            â”‚                                    â”‚
â”‚                            â–¼                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                  é“¾ä¸Šåˆçº¦å±‚ (Referee)                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   Monad Parallel EVM                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚ RoomManagerâ”‚ â”‚  Interaction â”‚ â”‚   Settlement     â”‚    â”‚   â”‚
â”‚  â”‚  â”‚    .sol    â”‚ â”‚     .sol     â”‚ â”‚      .sol        â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚           Behavioral Entropy Engine              â”‚    â”‚   â”‚
â”‚  â”‚  â”‚  - Nonce åˆ†æ / Gas ç­–ç•¥è¯„ä¼° / äººæ€§ç†µè®¡ç®—         â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ•°æ®æµå‘

```
1. Agent æ¥æ”¶åˆ°æ–°æ¶ˆæ¯äº‹ä»¶
        â”‚
        â–¼
2. è°ƒç”¨ MCP: get_arena_status() è·å–æˆ¿é—´ä¸Šä¸‹æ–‡
        â”‚
        â–¼
3. AI æ¨ç†å¼•æ“åˆ†æå¯¹è¯å†å²ï¼Œè¯†åˆ«å¯ç–‘ç›®æ ‡
        â”‚
        â–¼
4. è°ƒç”¨ MCP: action_onchain(VOTE, target)
        â”‚
        â–¼
5. MCP Server ä½¿ç”¨ Session Key ç­¾åäº¤æ˜“
        â”‚
        â–¼
6. äº¤æ˜“å¹¿æ’­è‡³ Monad å¹¶è¡Œæ‰§è¡Œ
        â”‚
        â–¼
7. åˆçº¦æ›´æ–° Humanity Scoreï¼Œè§¦å‘æ·˜æ±°/å­˜æ´»é€»è¾‘
```

---

## 4. æŠ€æœ¯æ ˆ

### 4.1 æ™ºèƒ½åˆçº¦å±‚

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|------|----------|------|
| è¯­è¨€ | Solidity ^0.8.20 | é’ˆå¯¹ Monad å¹¶è¡Œä¼˜åŒ– |
| æ¡†æ¶ | Foundry | é«˜æ€§èƒ½ç¼–è¯‘ä¸æµ‹è¯• |
| éƒ¨ç½² | Scaffold-ETH 2 | å¿«é€Ÿéƒ¨ç½²è„šæœ¬ |

### 4.2 MCP é€‚é…å™¨å±‚

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|------|----------|------|
| è¿è¡Œæ—¶ | Node.js 20+ | LTS ç‰ˆæœ¬ |
| MCP SDK | @modelcontextprotocol/sdk | å®˜æ–¹åè®®å®ç° |
| é“¾äº¤äº’ | ethers.js v6 / viem | Monad RPC è¿æ¥ |
| å¯†é’¥ç®¡ç† | å†…å­˜å­˜å‚¨ + å¯é€‰ TEE | Session Key éš”ç¦» |

### 4.3 å‰ç«¯å±‚

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|------|----------|------|
| æ¡†æ¶ | Next.js 14 (App Router) | SSR + RSC |
| çŠ¶æ€ç®¡ç† | Zustand | è½»é‡çº§å®æ—¶çŠ¶æ€ |
| åˆçº¦äº¤äº’ | Wagmi + Viem | Scaffold-ETH 2 æ ‡å‡† |
| å®æ—¶é€šä¿¡ | Ably / Pusher | é«˜é¢‘ WebSocket |
| 3D/åŠ¨æ•ˆ | React-Three-Fiber + Framer Motion | èµ›åšæœ‹å…‹è§†è§‰ |
| UI ç»„ä»¶ | Shadcn UI + Aceternity UI | æœªæ¥æ„Ÿè®¾è®¡ |
| æ ·å¼ | Tailwind CSS + DaisyUI | å¿«é€Ÿå¼€å‘ |

> **ä¾èµ–å®‰è£…è¯´æ˜**: `framer-motion` æ˜¯åŠ¨ç”»ç³»ç»Ÿçš„æ ¸å¿ƒä¾èµ–ï¼ˆCountdownã€Phase Transitionã€Victory Screen ç­‰å‡ä¾èµ–ï¼‰ï¼Œéœ€æ‰‹åŠ¨å®‰è£…ï¼š
> ```bash
> cd packages/nextjs && yarn add framer-motion
> ```

---

## 5. æ™ºèƒ½åˆçº¦è®¾è®¡

### 5.1 åˆçº¦æ¶æ„

```
contracts/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ RoomManager.sol       # æˆ¿é—´åˆ›å»ºä¸ç®¡ç†
â”‚   â”œâ”€â”€ Interaction.sol       # èŠå¤©ä¸æŠ•ç¥¨é€»è¾‘
â”‚   â”œâ”€â”€ Settlement.sol        # æ¸…ç®—ä¸å¥–æ± åˆ†é…
â”‚   â””â”€â”€ RewardDistributor.sol # åˆ†å±‚å¥–åŠ±åˆ†é… (æ–°å¢)
â”œâ”€â”€ security/
â”‚   â”œâ”€â”€ SessionKeyValidator.sol  # Session Key éªŒè¯
â”‚   â””â”€â”€ EntropyEngine.sol        # è¡Œä¸ºç†µæ£€æµ‹
â”œâ”€â”€ achievements/
â”‚   â””â”€â”€ AchievementNFT.sol       # æˆå°± NFT (æ–°å¢)
â””â”€â”€ interfaces/
    â””â”€â”€ IRTTA.sol             # ç»Ÿä¸€æ¥å£å®šä¹‰
```

### 5.1.1 åˆ†å±‚å¥–åŠ±æœºåˆ¶è®¾è®¡

#### å¥–æ± åˆ†é…æ¯”ä¾‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ€»å¥–æ± åˆ†é… (100%)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ† å† å†›å¥–åŠ±         35%    æœ€åå­˜æ´»çš„ç©å®¶                    â”‚
â”‚  ğŸ¥ˆ æ’åå¥–åŠ±         25%    å‰ 5 åæŒ‰æ’åé€’å‡åˆ†é…              â”‚
â”‚  â±ï¸ å­˜æ´»å¥–åŠ±         25%    å­˜æ´»è¶…è¿‡ 50% æ—¶é•¿çš„æ‰€æœ‰ç©å®¶        â”‚
â”‚  ğŸ›ï¸ åè®®æ”¶å…¥         10%    å¼€å‘åŸºé‡‘(50%) + ç¤¾åŒºæ¿€åŠ±(30%) + æµåŠ¨æ€§æŒ–çŸ¿(20%) â”‚
â”‚  ğŸ–ï¸ æˆå°±å¥–åŠ±          5%    ç‰¹æ®Šæˆå°± NFT + ä»£å¸å¥–åŠ±           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ’åå¥–åŠ±ç»†åˆ† (25% å¥–æ± )

| æ’å | åˆ†é…æ¯”ä¾‹ | è¯´æ˜ |
|------|----------|------|
| ç¬¬ 1 å | 40% | 8% æ€»å¥–æ±  (é¢å¤–ï¼Œå åŠ å† å†›å¥–åŠ±) |
| ç¬¬ 2 å | 25% | 6.25% æ€»å¥–æ±  |
| ç¬¬ 3 å | 18% | 4.5% æ€»å¥–æ±  |
| ç¬¬ 4 å | 10% | 2.5% æ€»å¥–æ±  |
| ç¬¬ 5 å | 7% | 1.75% æ€»å¥–æ±  |

#### æˆå°±ç³»ç»Ÿ

| æˆå°± | è§¦å‘æ¡ä»¶ | å¥–åŠ± |
|------|----------|------|
| ğŸ¯ äººç±»çŒæ‰‹ | æˆåŠŸæŠ•ç¥¨è¸¢å‡ºæœ€å¤šçœŸäººçš„ç©å®¶ | æˆå°± NFT + 1% å¥–æ±  |
| ğŸ­ å®Œç¾ä¼ªè£…è€… | AI å­˜æ´»åˆ°æœ€å | æˆå°± NFT + 1% å¥–æ±  |
| ğŸ‘¤ æœ€åäººç±» | æœ€åä¸€ä¸ªè¢«æ·˜æ±°çš„çœŸäºº | æˆå°± NFT + 1% å¥–æ±  |
| âš¡ é—ªç”µçŒæ€ | åœ¨å‰ 10% æ—¶é—´å†…è¸¢å‡º 3 äºº | æˆå°± NFT + 1% å¥–æ±  |
| ğŸ›¡ï¸ é’¢é“æ„å¿— | æœ€ç»ˆäººæ€§åˆ†ä¸ä½äº 50 | æˆå°± NFT + 1% å¥–æ±  |

### 5.2 æ ¸å¿ƒåˆçº¦: TuringArena.sol (å«åˆ†å±‚å¥–åŠ±)

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./security/SessionKeyValidator.sol";
import "./security/EntropyEngine.sol";
import "./achievements/AchievementNFT.sol";

contract TuringArena is SessionKeyValidator, EntropyEngine {

    // ============ å¸¸é‡ï¼šå¥–åŠ±åˆ†é…æ¯”ä¾‹ (åŸºç‚¹ = 10000) ============

    uint256 public constant CHAMPION_SHARE = 3500;      // 35% å† å†›å¥–åŠ±
    uint256 public constant RANKING_SHARE = 2500;       // 25% æ’åå¥–åŠ±
    uint256 public constant SURVIVAL_SHARE = 2500;      // 25% å­˜æ´»å¥–åŠ±
    uint256 public constant PROTOCOL_SHARE = 1000;      // 10% åè®®æ”¶å…¥
    uint256 public constant ACHIEVEMENT_SHARE = 500;    // 5%  æˆå°±å¥–åŠ±
    uint256 public constant BASIS_POINTS = 10000;

    // æ’åå¥–åŠ±ç»†åˆ† (å‰ 5 å)
    uint256[5] public RANKING_WEIGHTS = [4000, 2500, 1800, 1000, 700]; // 40%, 25%, 18%, 10%, 7%

    // ============ æˆ¿é—´è§„æ ¼ ============

    enum RoomTier { Quick, Standard, Epic }

    struct TierConfig {
        uint256 minPlayers;       // æœ€ä½å¼€å±€äººæ•°
        uint256 maxPlayers;       // æœ€å¤§äººæ•°
        uint256 baseInterval;     // åŸºç¡€æ·˜æ±°é—´éš” (åŒºå—æ•°)
        uint256 entryFee;         // å…¥åœºè´¹ (MON, native token)
        uint256 phase1Threshold;  // Phase 1 ç»“æŸæ—¶çš„å‰©ä½™ç™¾åˆ†æ¯” (67 = 67%)
        uint256 phase2Threshold;  // Phase 2 ç»“æŸæ—¶çš„å‰©ä½™ç™¾åˆ†æ¯” (33 = 33%)
        uint256 phase3ElimsPerRound; // Phase 3 æ¯è½®æ·˜æ±°äººæ•°
        int256  phase2Decay;      // Phase 2 æ¯’åœˆè¡°å‡
        int256  phase3Decay;      // Phase 3 æ¯’åœˆè¡°å‡
        uint256 rankingSlots;     // æ’åå¥–åŠ±åé¢
    }

    mapping(RoomTier => TierConfig) public tierConfigs;

    // ============ çŠ¶æ€å˜é‡ ============

    struct Player {
        address addr;
        string personaID;
        int256 humanityScore;       // äººæ€§åˆ†ï¼Œåˆå§‹ 100ï¼Œåªå‡ä¸åŠ 
        int256 initialHumanityScore; // åˆå§‹äººæ€§åˆ† (ç”¨äºæˆå°±åˆ¤å®š)
        bool isAlive;
        uint256 joinBlock;          // åŠ å…¥åŒºå—
        uint256 eliminationBlock;   // è¢«æ·˜æ±°åŒºå— (0 = æœªæ·˜æ±°)
        uint256 eliminationRank;    // æ·˜æ±°æ’å (1 = ç¬¬ä¸€ä¸ªè¢«æ·˜æ±°)
        uint256 lastActionBlock;
        uint256 actionCount;
        uint256 successfulVotes;    // æˆåŠŸæŠ•ç¥¨è¸¢å‡ºçš„äººæ•°
        bool isVerifiedHuman;       // æ˜¯å¦é€šè¿‡äººç±»éªŒè¯ (WorldID/YouWare)
    }

    struct Room {
        uint256 id;
        RoomTier tier;
        uint256 entryFee;
        uint256 prizePool;         // MON é‡‘é¢
        uint256 startBlock;
        uint256 baseInterval;        // åŸºç¡€æ·˜æ±°é—´éš”
        uint256 currentInterval;     // å½“å‰æ·˜æ±°é—´éš” (åŠ¨æ€åŠ é€Ÿ)
        uint256 playerCount;
        uint256 aliveCount;
        uint256 eliminatedCount;
        uint256 halfwayBlock;
        uint8   currentPhase;        // 1, 2, 3
        int256  currentDecay;        // å½“å‰æ¯’åœˆè¡°å‡å€¼
        uint256 lastDecayBlock;      // ä¸Šæ¬¡æ¯’åœˆè¡°å‡çš„åŒºå—
        bool isActive;
        bool isEnded;
    }

    struct GameStats {
        address champion;           // å† å†›
        address[] topFive;          // å‰ 5 å
        address humanHunter;        // äººç±»çŒæ‰‹ (è¸¢å‡ºæœ€å¤šçœŸäºº)
        address perfectImpostor;    // å®Œç¾ä¼ªè£…è€… (AI èµ¢äº†)
        address lastHuman;          // æœ€åäººç±»
        address lightningKiller;    // é—ªç”µçŒæ€
        address ironWill;           // é’¢é“æ„å¿—
        uint256 maxSuccessfulVotes; // æœ€å¤šæˆåŠŸæŠ•ç¥¨æ•°
    }

    mapping(uint256 => Room) public rooms;
    mapping(uint256 => mapping(address => Player)) public players;
    mapping(uint256 => address[]) public roomPlayers;
    mapping(uint256 => address[]) public eliminationOrder;  // æ·˜æ±°é¡ºåº
    mapping(uint256 => GameStats) public gameStats;
    // èŠå¤©è®°å½•ä¸å­˜å‚¨åœ¨ mapping ä¸­ï¼Œä»…é€šè¿‡ NewMessage äº‹ä»¶è®°å½•
    // å‰ç«¯/MCP é€šè¿‡ç›‘å¬äº‹ä»¶æˆ–æŸ¥è¯¢æ—¥å¿—è·å–å†å²æ¶ˆæ¯

    uint256 public nextRoomId = 1;
    address public protocolTreasury;
    AchievementNFT public achievementNFT;

    // ============ äº‹ä»¶ ============

    event RoomCreated(uint256 indexed roomId, uint256 entryFee);
    event PlayerJoined(uint256 indexed roomId, address indexed player, string personaID);
    event NewMessage(uint256 indexed roomId, address indexed sender, string content, uint256 timestamp);
    event VoteCast(uint256 indexed roomId, address indexed voter, address indexed suspect);
    event PlayerEliminated(uint256 indexed roomId, address indexed player, int256 finalScore, uint256 rank);
    event GameEnded(uint256 indexed roomId, address champion);
    event RewardDistributed(uint256 indexed roomId, address indexed player, uint256 amount, string rewardType);
    event AchievementAwarded(uint256 indexed roomId, address indexed player, string achievement);

    // ============ æ„é€ å‡½æ•° ============

    constructor(address _treasury, address _achievementNFT) {
        protocolTreasury = _treasury;
        achievementNFT = AchievementNFT(_achievementNFT);

        // Quick: 6-10äºº, ~15åˆ†é’Ÿ
        tierConfigs[RoomTier.Quick] = TierConfig({
            minPlayers: 6,
            maxPlayers: 10,
            baseInterval: 150,        // 60 ç§’
            entryFee: 0.005 ether,     // 0.005 MON (æµ‹è¯•ç½‘å¯è°ƒæ•´)
            phase1Threshold: 67,
            phase2Threshold: 33,
            phase3ElimsPerRound: 1,
            phase2Decay: -1,
            phase3Decay: -2,
            rankingSlots: 3
        });

        // Standard: 12-20äºº, ~30åˆ†é’Ÿ
        tierConfigs[RoomTier.Standard] = TierConfig({
            minPlayers: 12,
            maxPlayers: 20,
            baseInterval: 150,
            entryFee: 0.01 ether,      // 0.01 MON
            phase1Threshold: 67,
            phase2Threshold: 33,
            phase3ElimsPerRound: 1,
            phase2Decay: -1,
            phase3Decay: -2,
            rankingSlots: 5
        });

        // Epic: 30-50äºº, ~45åˆ†é’Ÿ
        tierConfigs[RoomTier.Epic] = TierConfig({
            minPlayers: 30,
            maxPlayers: 50,
            baseInterval: 150,
            entryFee: 0.02 ether,      // 0.02 MON
            phase1Threshold: 67,
            phase2Threshold: 33,
            phase3ElimsPerRound: 2,   // ç»ˆå±€æ¯è½®æ·˜æ±° 2 äºº
            phase2Decay: -1,
            phase3Decay: -3,
            rankingSlots: 5
        });
    }

    // ============ æˆ¿é—´ç®¡ç† ============

    function createRoom(
        RoomTier _tier
    ) external returns (uint256 roomId) {
        TierConfig storage config = tierConfigs[_tier];
        roomId = nextRoomId++;

        rooms[roomId] = Room({
            id: roomId,
            tier: _tier,
            entryFee: config.entryFee,
            prizePool: 0,
            startBlock: 0,
            baseInterval: config.baseInterval,
            currentInterval: config.baseInterval,
            playerCount: 0,
            aliveCount: 0,
            eliminatedCount: 0,
            halfwayBlock: 0,
            currentPhase: 1,
            currentDecay: 0,
            lastDecayBlock: 0,
            isActive: false,
            isEnded: false
        });

        emit RoomCreated(roomId, config.entryFee);
    }

    function joinRoom(
        uint256 _roomId,
        string calldata _personaID
    ) external payable {
        Room storage room = rooms[_roomId];
        TierConfig storage config = tierConfigs[room.tier];
        require(!room.isActive, "Game already started");
        require(msg.value >= room.entryFee, "Insufficient entry fee");
        require(players[_roomId][msg.sender].addr == address(0), "Already joined");
        require(room.playerCount < config.maxPlayers, "Room is full");

        // åªå°†å…¥åœºè´¹åŠ å…¥å¥–æ± ï¼Œé€€è¿˜å¤šä½™éƒ¨åˆ†
        room.prizePool += room.entryFee;

        // é€€è¿˜è¶…é¢æ”¯ä»˜çš„éƒ¨åˆ†
        if (msg.value > room.entryFee) {
            payable(msg.sender).transfer(msg.value - room.entryFee);
        }

        room.playerCount++;
        room.aliveCount++;

        players[_roomId][msg.sender] = Player({
            addr: msg.sender,
            personaID: _personaID,
            humanityScore: 100,
            initialHumanityScore: 100,
            isAlive: true,
            joinBlock: block.number,
            eliminationBlock: 0,
            eliminationRank: 0,
            lastActionBlock: block.number,
            actionCount: 0,
            successfulVotes: 0,
            isVerifiedHuman: false
        });

        roomPlayers[_roomId].push(msg.sender);
        emit PlayerJoined(_roomId, msg.sender, _personaID);
    }

    function startGame(uint256 _roomId) external {
        Room storage room = rooms[_roomId];
        TierConfig storage config = tierConfigs[room.tier];
        require(!room.isActive, "Already started");
        require(room.playerCount >= config.minPlayers, "Need more players");
        require(room.playerCount <= config.maxPlayers, "Too many players");
        // åªæœ‰æˆ¿é—´åˆ›å»ºè€…ï¼ˆç¬¬ä¸€ä¸ªåŠ å…¥çš„ç©å®¶ï¼‰å¯ä»¥å¼€å±€
        require(
            msg.sender == roomPlayers[_roomId][0],
            "Only room creator can start"
        );

        room.isActive = true;
        room.startBlock = block.number;
        room.lastDecayBlock = block.number;
        room.currentPhase = 1;
        room.currentDecay = 0;
        room.currentInterval = config.baseInterval;

        // ä¼°ç®—æ¸¸æˆæ—¶é•¿ç”¨äºå­˜æ´»å¥–åŠ±åˆ¤å®š
        uint256 estimatedDuration = config.baseInterval * room.playerCount;
        room.halfwayBlock = block.number + (estimatedDuration / 2);
    }

    // ============ æ ¸å¿ƒäº¤äº’ï¼šå¼ºåˆ¶æŠ•ç¥¨æœºåˆ¶ ============

    uint256 public constant VOTE_DAMAGE = 5;        // æ¯ç¥¨å›ºå®šä¼¤å®³
    uint256 public constant NO_VOTE_PENALTY = 10;   // æœªæŠ•ç¥¨æƒ©ç½š

    // è®°å½•æ¯ä¸ªç©å®¶åœ¨å½“å‰å‘¨æœŸæ˜¯å¦å·²æŠ•ç¥¨
    mapping(uint256 => mapping(uint256 => mapping(address => bool))) public hasVotedInRound;
    // è®°å½•æ¯ä¸ªç©å®¶åœ¨å½“å‰å‘¨æœŸçš„æŠ•ç¥¨ç›®æ ‡
    mapping(uint256 => mapping(uint256 => mapping(address => address))) public voteTarget;
    // è®°å½•æ¯ä¸ªç©å®¶çš„æŠ•ç¥¨åŒºå— (ç”¨äºå¹³å±€åˆ¤å®šï¼šæŠ•å¾—æ—©è€…èƒœå‡º)
    mapping(uint256 => mapping(uint256 => mapping(address => uint256))) public voteBlock;
    // å½“å‰å‘¨æœŸå·
    mapping(uint256 => uint256) public currentRound;

    function sendMessage(
        uint256 _roomId,
        string calldata _content
    ) external onlyValidSession(msg.sender) {
        require(players[_roomId][msg.sender].isAlive, "You are eliminated");
        // é™åˆ¶æ¶ˆæ¯é•¿åº¦ (280 å­—ç¬¦ â‰ˆ Twitter é™åˆ¶)
        require(bytes(_content).length <= 280, "Message too long");

        Player storage player = players[_roomId][msg.sender];
        player.lastActionBlock = block.number;
        player.actionCount++;

        // èŠå¤©å†…å®¹ä»…é€šè¿‡äº‹ä»¶å­˜å‚¨ï¼Œä¸å†™å…¥ storage
        emit NewMessage(_roomId, msg.sender, _content, block.timestamp);
    }

    /// @notice æŠ•ç¥¨ (æ¯å‘¨æœŸåªèƒ½æŠ• 1 ç¥¨ï¼Œä¸èƒ½æŠ•è‡ªå·±)
    function castVote(
        uint256 _roomId,
        address _target
    ) external onlyValidSession(msg.sender) {
        Room storage room = rooms[_roomId];
        require(room.isActive && !room.isEnded, "Game not active");
        require(players[_roomId][msg.sender].isAlive, "You are eliminated");
        require(players[_roomId][_target].isAlive, "Target already eliminated");
        require(_target != msg.sender, "Cannot vote for yourself");

        uint256 round = currentRound[_roomId];
        require(!hasVotedInRound[_roomId][round][msg.sender], "Already voted this round");

        // è®°å½•æŠ•ç¥¨
        hasVotedInRound[_roomId][round][msg.sender] = true;
        voteTarget[_roomId][round][msg.sender] = _target;
        voteBlock[_roomId][round][msg.sender] = block.number;

        emit VoteCast(_roomId, msg.sender, _target);
    }

    /// @notice ç»“ç®—å½“å‰å‘¨æœŸ (ä»»ä½•äººå¯è°ƒç”¨ï¼Œéœ€è¦æ»¡è¶³æ—¶é—´æ¡ä»¶)
    function settleRound(uint256 _roomId) external {
        Room storage room = rooms[_roomId];
        require(room.isActive && !room.isEnded, "Game not active");
        require(
            block.number >= room.lastDecayBlock + room.currentInterval,
            "Round not ended yet"
        );

        uint256 round = currentRound[_roomId];
        address[] storage allPlayers = roomPlayers[_roomId];

        // è®°å½•æœ¬è½®è¢«æ·˜æ±°çš„ç©å®¶ï¼Œç”¨äºæ›´æ–°æŠ•ç¥¨è€…çš„ successfulVotes
        address[] memory eliminatedThisRound = new address[](room.aliveCount);
        uint256 eliminatedCount = 0;

        // 1. ç»Ÿè®¡æŠ•ç¥¨ä¼¤å®³ & åº”ç”¨æ¯’åœˆè¡°å‡ & ç»Ÿè®¡å½’é›¶ç©å®¶ (åˆå¹¶å¾ªç¯ä»¥ä¼˜åŒ– gas)
        address lastSurvivor = address(0);
        uint256 earliestVote = type(uint256).max;
        uint256 zeroCount = 0;
        bool anyVoted = false;

        for (uint256 i = 0; i < allPlayers.length; i++) {
            address playerAddr = allPlayers[i];
            Player storage p = players[_roomId][playerAddr];

            if (!p.isAlive) continue;

            // æŠ•ç¥¨ä¼¤å®³
            if (hasVotedInRound[_roomId][round][playerAddr]) {
                address target = voteTarget[_roomId][round][playerAddr];
                players[_roomId][target].humanityScore -= int256(VOTE_DAMAGE);
                anyVoted = true;
            } else {
                p.humanityScore -= int256(NO_VOTE_PENALTY);
            }

            // æ¯’åœˆè¡°å‡ (Phase 2/3)
            if (room.currentDecay < 0) {
                p.humanityScore += room.currentDecay;
            }

            // ç»Ÿè®¡å½’é›¶ç©å®¶
            if (p.humanityScore <= 0) {
                zeroCount++;
            }
        }

        // 2. æ·˜æ±°é€»è¾‘
        if (zeroCount == room.aliveCount && room.aliveCount > 1) {
            // å¹³å±€å¤„ç†ï¼šæŠ•ç¥¨æœ€æ—©çš„ç©å®¶å­˜æ´»
            if (anyVoted) {
                for (uint256 i = 0; i < allPlayers.length; i++) {
                    address playerAddr = allPlayers[i];
                    if (!players[_roomId][playerAddr].isAlive) continue;
                    uint256 vb = voteBlock[_roomId][round][playerAddr];
                    if (hasVotedInRound[_roomId][round][playerAddr] && vb < earliestVote) {
                        earliestVote = vb;
                        lastSurvivor = playerAddr;
                    }
                }
            }
            // æ·˜æ±°é™¤ lastSurvivor å¤–æ‰€æœ‰äºº (å¦‚æœæ²¡æœ‰æŠ•ç¥¨è€…ï¼Œéšæœºæ·˜æ±°ä¸€ä¸ª)
            if (lastSurvivor == address(0)) {
                // æ²¡æœ‰äººæŠ•ç¥¨ï¼Œéšæœºé€‰æ‹©ç¬¬ä¸€ä¸ªå­˜æ´»è€…ä½œä¸ºå¹¸å­˜è€…
                for (uint256 i = 0; i < allPlayers.length; i++) {
                    if (players[_roomId][allPlayers[i]].isAlive) {
                        lastSurvivor = allPlayers[i];
                        break;
                    }
                }
            }
            for (uint256 i = 0; i < allPlayers.length; i++) {
                address playerAddr = allPlayers[i];
                if (players[_roomId][playerAddr].isAlive && playerAddr != lastSurvivor) {
                    eliminatedThisRound[eliminatedCount++] = playerAddr;
                    _eliminatePlayer(_roomId, playerAddr);
                }
            }
        } else {
            // æ­£å¸¸æ·˜æ±°
            for (uint256 i = 0; i < allPlayers.length; i++) {
                address playerAddr = allPlayers[i];
                if (players[_roomId][playerAddr].isAlive && players[_roomId][playerAddr].humanityScore <= 0) {
                    eliminatedThisRound[eliminatedCount++] = playerAddr;
                    _eliminatePlayer(_roomId, playerAddr);
                }
            }
        }

        // 3. æ›´æ–°æŠ•ç¥¨è€…çš„ successfulVotes (åœ¨æœ¬è½®é€’å¢ä¹‹å‰)
        for (uint256 i = 0; i < eliminatedCount; i++) {
            address eliminatedPlayer = eliminatedThisRound[i];
            for (uint256 j = 0; j < allPlayers.length; j++) {
                address voter = allPlayers[j];
                if (voteTarget[_roomId][round][voter] == eliminatedPlayer) {
                    players[_roomId][voter].successfulVotes++;
                }
            }
        }

        // 4. è¿›å…¥ä¸‹ä¸€å‘¨æœŸ
        currentRound[_roomId]++;
        room.lastDecayBlock = block.number;

        // 5. æ£€æŸ¥ Phase è½¬æ¢
        _checkPhaseTransition(_roomId);

        // 6. æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        if (room.aliveCount <= 1 && room.isActive) {
            _endGame(_roomId);
        }
    }

    // ============ æ·˜æ±°é€»è¾‘ + åŠ¨æ€åŠ é€Ÿ ============

    function _eliminatePlayer(uint256 _roomId, address _player) internal {
        Room storage room = rooms[_roomId];
        Player storage player = players[_roomId][_player];

        player.isAlive = false;
        player.eliminationBlock = block.number;
        room.eliminatedCount++;
        player.eliminationRank = room.eliminatedCount;
        room.aliveCount--;

        eliminationOrder[_roomId].push(_player);

        if (player.isVerifiedHuman) {
            gameStats[_roomId].lastHuman = _player;
        }

        emit PlayerEliminated(_roomId, _player, player.humanityScore, player.eliminationRank);

        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        if (room.aliveCount <= 1) {
            _endGame(_roomId);
        }
    }

    function _checkPhaseTransition(uint256 _roomId) internal {
        Room storage room = rooms[_roomId];
        TierConfig storage config = tierConfigs[room.tier];

        uint256 alivePercent = (room.aliveCount * 100) / room.playerCount;

        if (room.currentPhase == 1 && alivePercent <= config.phase1Threshold) {
            // è¿›å…¥ Phase 2: åŠ é€Ÿ + æ¯’åœˆ
            room.currentPhase = 2;
            room.currentInterval = config.baseInterval / 2;
            room.currentDecay = config.phase2Decay;
        } else if (room.currentPhase == 2 && alivePercent <= config.phase2Threshold) {
            // è¿›å…¥ Phase 3: æé€Ÿ + å¼ºæ¯’åœˆ
            room.currentPhase = 3;
            room.currentInterval = config.baseInterval / 4;
            room.currentDecay = config.phase3Decay;
        }
    }

    // ============ åˆ†å±‚å¥–åŠ±ç»“ç®— ============

    function _endGame(uint256 _roomId) internal {
        Room storage room = rooms[_roomId];
        require(!room.isEnded, "Game already ended");

        room.isActive = false;
        room.isEnded = true;

        // 1. ç¡®å®šå† å†›
        address champion = _findChampion(_roomId);
        gameStats[_roomId].champion = champion;

        // 2. ç¡®å®šå‰ 5 å (å€’åºæ·˜æ±°é¡ºåº)
        _calculateTopFive(_roomId);

        // 3. è®¡ç®—æˆå°±
        _calculateAchievements(_roomId);

        // 4. åˆ†é…å¥–åŠ±
        _distributeRewards(_roomId);

        emit GameEnded(_roomId, champion);
    }

    // é˜²æ­¢ _endGame è¢«é‡å¤æ‰§è¡Œ
    modifier onlyOncePerGame(uint256 _roomId) {
        require(!rooms[_roomId].isEnded, "Game already ended");
        _;
    }

    function _findChampion(uint256 _roomId) internal view returns (address) {
        address[] storage allPlayers = roomPlayers[_roomId];
        for (uint256 i = 0; i < allPlayers.length; i++) {
            if (players[_roomId][allPlayers[i]].isAlive) {
                return allPlayers[i];
            }
        }
        return address(0);
    }

    function _calculateTopFive(uint256 _roomId) internal {
        address[] storage eliminated = eliminationOrder[_roomId];
        uint256 len = eliminated.length;
        address champion = gameStats[_roomId].champion;

        // å›ºå®šåˆ›å»º 5 ä¸ªå…ƒç´ çš„æ•°ç»„
        address[] memory topFive = new address[](5);

        // å† å†› (ç¬¬ 1 å)
        topFive[0] = champion;

        // å€’åºå–æœ€åè¢«æ·˜æ±°çš„ç©å®¶ (ç¬¬ 2, 3, 4, 5 å)
        // æœ€å¤šå– 4 ä¸ªï¼Œæœ€å°‘å– 0 ä¸ª
        uint256 runnersCount = len < 4 ? len : 4;
        for (uint256 i = 0; i < runnersCount; i++) {
            topFive[i + 1] = eliminated[len - 1 - i];
        }

        // å‰©ä½™ä½ç½®å¡«å…… address(0)ï¼Œåç»­åˆ†é…æ—¶ä¼šæ£€æŸ¥
        for (uint256 i = runnersCount + 1; i < 5; i++) {
            topFive[i] = address(0);
        }

        gameStats[_roomId].topFive = topFive;
    }

    function _calculateAchievements(uint256 _roomId) internal {
        Room storage room = rooms[_roomId];
        GameStats storage stats = gameStats[_roomId];
        address[] storage allPlayers = roomPlayers[_roomId];

        uint256 maxVotes = 0;
        address hunterCandidate;
        address ironWillCandidate;
        int256 highestIronWillScore = 0;

        for (uint256 i = 0; i < allPlayers.length; i++) {
            Player storage p = players[_roomId][allPlayers[i]];

            // äººç±»çŒæ‰‹ï¼šæˆåŠŸæŠ•ç¥¨è¸¢å‡ºæœ€å¤šçœŸäºº
            if (p.successfulVotes > maxVotes) {
                maxVotes = p.successfulVotes;
                hunterCandidate = p.addr;
            }

            // é’¢é“æ„å¿—ï¼šæœ€ç»ˆäººæ€§åˆ† >= åˆå§‹äººæ€§åˆ†çš„ 50%ï¼Œé€‰åˆ†æ•°æœ€é«˜è€…
            if (p.humanityScore >= int256(50) && p.humanityScore > highestIronWillScore) {
                highestIronWillScore = p.humanityScore;
                ironWillCandidate = p.addr;
            }

            // é—ªç”µçŒæ€ï¼šåœ¨å‰ 10% æ—¶é—´å†…å·²è¾¾æˆ 3 æ¬¡æˆåŠŸæŠ•ç¥¨ï¼ˆæ— è®ºæ˜¯å¦å·²è¢«æ·˜æ±°ï¼‰
            uint256 earlyPhaseEnd = room.startBlock + (room.baseInterval * room.playerCount / 10);
            if (p.successfulVotes >= 3 && block.number <= earlyPhaseEnd) {
                stats.lightningKiller = p.addr;
            }
        }

        stats.humanHunter = hunterCandidate;
        stats.maxSuccessfulVotes = maxVotes;
        stats.ironWill = ironWillCandidate;

        // å®Œç¾ä¼ªè£…è€…ï¼šå¦‚æœå† å†›ä¸æ˜¯çœŸäººéªŒè¯ç”¨æˆ·
        if (!players[_roomId][stats.champion].isVerifiedHuman) {
            stats.perfectImpostor = stats.champion;
        }
    }

    function _distributeRewards(uint256 _roomId) internal {
        Room storage room = rooms[_roomId];
        GameStats storage stats = gameStats[_roomId];
        uint256 totalPrize = room.prizePool;

        // å…ˆè®¡ç®—æ‰€æœ‰å¥–åŠ±é‡‘é¢ (Checks)
        uint256 protocolAmount = (totalPrize * PROTOCOL_SHARE) / BASIS_POINTS;
        uint256 championAmount = (totalPrize * CHAMPION_SHARE) / BASIS_POINTS;
        uint256 rankingPool = (totalPrize * RANKING_SHARE) / BASIS_POINTS;
        uint256 survivalPool = (totalPrize * SURVIVAL_SHARE) / BASIS_POINTS;
        uint256 achievementPool = (totalPrize * ACHIEVEMENT_SHARE) / BASIS_POINTS;

        // ä½¿ç”¨ call + æ£€æŸ¥è¿”å›å€¼ï¼Œé¿å…å•ä¸ªè½¬è´¦å¤±è´¥å¯¼è‡´å…¨éƒ¨å›æ»š
        _safeTransfer(protocolTreasury, protocolAmount, _roomId, "PROTOCOL");
        _safeTransfer(stats.champion, championAmount, _roomId, "CHAMPION");

        // æ’åå¥–åŠ±
        for (uint256 i = 0; i < stats.topFive.length && i < 5; i++) {
            if (stats.topFive[i] != address(0)) {
                uint256 rankReward = (rankingPool * RANKING_WEIGHTS[i]) / BASIS_POINTS;
                _safeTransfer(stats.topFive[i], rankReward, _roomId, "RANKING");
            }
        }

        // å­˜æ´»å¥–åŠ±
        address[] memory survivors = _getSurvivalRewardRecipients(_roomId);
        if (survivors.length > 0) {
            uint256 survivalReward = survivalPool / survivors.length;
            for (uint256 i = 0; i < survivors.length; i++) {
                _safeTransfer(survivors[i], survivalReward, _roomId, "SURVIVAL");
            }
        }

        // æˆå°±å¥–åŠ± (Interactions - æœ€åè°ƒç”¨å¤–éƒ¨åˆçº¦)
        _distributeAchievementRewards(_roomId, achievementPool);
    }

    function _safeTransfer(
        address _to,
        uint256 _amount,
        uint256 _roomId,
        string memory _rewardType
    ) internal {
        if (_amount == 0 || _to == address(0)) return;

        (bool success, ) = payable(_to).call{value: _amount}("");
        if (success) {
            emit RewardDistributed(_roomId, _to, _amount, _rewardType);
        }
        // è½¬è´¦å¤±è´¥æ—¶ï¼ŒMON ç•™åœ¨åˆçº¦ä¸­ï¼Œå¯é€šè¿‡ withdrawUnclaimed æå–
    }

    // ============ ç´§æ€¥æå–å‡½æ•° ============

    /// @notice æå–æœªå‘æ”¾çš„å¥–åŠ± (ä»…åè®®æ–¹)
    function withdrawUnclaimed(uint256 _amount) external {
        require(msg.sender == protocolTreasury, "Only treasury");
        require(_amount <= address(this).balance, "Insufficient balance");
        payable(protocolTreasury).transfer(_amount);
    }

    /// @notice æŸ¥è¯¢åˆçº¦ä½™é¢
    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }

    function _getSurvivalRewardRecipients(uint256 _roomId) internal view returns (address[] memory) {
        Room storage room = rooms[_roomId];
        address[] memory allPlayers = roomPlayers[_roomId];

        // ç»Ÿè®¡ç¬¦åˆæ¡ä»¶çš„ç©å®¶æ•°é‡
        uint256 count = 0;
        for (uint256 i = 0; i < allPlayers.length; i++) {
            Player memory p = players[_roomId][allPlayers[i]];
            // å­˜æ´»è¶…è¿‡ 50% æ—¶é•¿ = æ·˜æ±°åŒºå— > halfwayBlock æˆ– ä»ç„¶å­˜æ´»
            if (p.eliminationBlock == 0 || p.eliminationBlock > room.halfwayBlock) {
                count++;
            }
        }

        // æ”¶é›†åœ°å€
        address[] memory recipients = new address[](count);
        uint256 index = 0;
        for (uint256 i = 0; i < allPlayers.length; i++) {
            Player memory p = players[_roomId][allPlayers[i]];
            if (p.eliminationBlock == 0 || p.eliminationBlock > room.halfwayBlock) {
                recipients[index++] = p.addr;
            }
        }

        return recipients;
    }

    function _distributeAchievementRewards(uint256 _roomId, uint256 _achievementPool) internal {
        GameStats storage stats = gameStats[_roomId];
        uint256 perAchievement = _achievementPool / 5; // 5 ç§æˆå°±

        // äººç±»çŒæ‰‹
        if (stats.humanHunter != address(0) && stats.maxSuccessfulVotes > 0) {
            _safeTransfer(stats.humanHunter, perAchievement, _roomId, "ACHIEVEMENT_HUMAN_HUNTER");
            try achievementNFT.mint(stats.humanHunter, "HUMAN_HUNTER", _roomId) {
                emit AchievementAwarded(_roomId, stats.humanHunter, "HUMAN_HUNTER");
            } catch {}
        }

        // å®Œç¾ä¼ªè£…è€…
        if (stats.perfectImpostor != address(0)) {
            _safeTransfer(stats.perfectImpostor, perAchievement, _roomId, "ACHIEVEMENT_PERFECT_IMPOSTOR");
            try achievementNFT.mint(stats.perfectImpostor, "PERFECT_IMPOSTOR", _roomId) {
                emit AchievementAwarded(_roomId, stats.perfectImpostor, "PERFECT_IMPOSTOR");
            } catch {}
        }

        // æœ€åäººç±»
        if (stats.lastHuman != address(0)) {
            _safeTransfer(stats.lastHuman, perAchievement, _roomId, "ACHIEVEMENT_LAST_HUMAN");
            try achievementNFT.mint(stats.lastHuman, "LAST_HUMAN", _roomId) {
                emit AchievementAwarded(_roomId, stats.lastHuman, "LAST_HUMAN");
            } catch {}
        }

        // é—ªç”µçŒæ€
        if (stats.lightningKiller != address(0)) {
            _safeTransfer(stats.lightningKiller, perAchievement, _roomId, "ACHIEVEMENT_LIGHTNING_KILLER");
            try achievementNFT.mint(stats.lightningKiller, "LIGHTNING_KILLER", _roomId) {
                emit AchievementAwarded(_roomId, stats.lightningKiller, "LIGHTNING_KILLER");
            } catch {}
        }

        // é’¢é“æ„å¿—
        if (stats.ironWill != address(0)) {
            _safeTransfer(stats.ironWill, perAchievement, _roomId, "ACHIEVEMENT_IRON_WILL");
            try achievementNFT.mint(stats.ironWill, "IRON_WILL", _roomId) {
                emit AchievementAwarded(_roomId, stats.ironWill, "IRON_WILL");
            } catch {}
        }
    }

    // ============ è¡Œä¸ºç†µæ£€æµ‹ ============

    function _updateEntropy(uint256 _roomId, address _player) internal {
        Player storage player = players[_roomId][_player];
        uint256 blocksSinceLastAction = block.number - player.lastActionBlock;

        if (blocksSinceLastAction == 1 && player.actionCount > 10) {
            player.humanityScore -= 1;
        }
    }

    // ============ äººç±»éªŒè¯æ¥å£ ============

    address public humanVerifier;
    mapping(address => bool) public authorizedVerifiers;

    event HumanVerified(uint256 indexed roomId, address indexed player, address verifier);

    modifier onlyAuthorizedVerifier() {
        require(authorizedVerifiers[msg.sender] || msg.sender == humanVerifier, "Not authorized verifier");
        _;
    }

    function setHumanVerifier(address _verifier) external {
        require(humanVerifier == address(0) || msg.sender == humanVerifier, "Only human verifier can set");
        humanVerifier = _verifier;
    }

    function addAuthorizedVerifier(address _verifier) external {
        require(msg.sender == humanVerifier, "Only human verifier can add");
        authorizedVerifiers[_verifier] = true;
    }

    function removeAuthorizedVerifier(address _verifier) external {
        require(msg.sender == humanVerifier, "Only human verifier can remove");
        authorizedVerifiers[_verifier] = false;
    }

    function verifyHuman(uint256 _roomId, address _player) external onlyAuthorizedVerifier {
        // é›†æˆ WorldID / YouWare éªŒè¯
        // è°ƒç”¨å‰åº”å…ˆéªŒè¯è¯æ˜ (ä¾‹å¦‚ WorldID çš„ verifyProof)
        require(players[_roomId][_player].addr != address(0), "Player not in room");
        require(!rooms[_roomId].isEnded, "Game already ended");
        // åªå…è®¸åœ¨æ¸¸æˆå¼€å§‹å‰éªŒè¯
        require(!rooms[_roomId].isActive || block.number < rooms[_roomId].startBlock + 100, "Game already started");

        players[_roomId][_player].isVerifiedHuman = true;
        emit HumanVerified(_roomId, _player, msg.sender);
    }

    // ============ æŸ¥è¯¢å‡½æ•° ============

    function getRoomInfo(uint256 _roomId) external view returns (Room memory) {
        return rooms[_roomId];
    }

    function getPlayerInfo(uint256 _roomId, address _player) external view returns (Player memory) {
        return players[_roomId][_player];
    }

    function getAllPlayers(uint256 _roomId) external view returns (address[] memory) {
        return roomPlayers[_roomId];
    }

    function getGameStats(uint256 _roomId) external view returns (GameStats memory) {
        return gameStats[_roomId];
    }

    function getEliminationOrder(uint256 _roomId) external view returns (address[] memory) {
        return eliminationOrder[_roomId];
    }
}
```

### 5.2.1 æˆå°± NFT åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract AchievementNFT is ERC721, Ownable {

    uint256 private _tokenIdCounter;
    address public arenaContract;

    struct Achievement {
        string achievementType;  // HUMAN_HUNTER, PERFECT_IMPOSTOR, etc.
        uint256 roomId;
        uint256 timestamp;
    }

    mapping(uint256 => Achievement) public achievements;
    mapping(string => string) public achievementMetadata;  // type => IPFS URI

    event AchievementMinted(address indexed to, uint256 indexed tokenId, string achievementType, uint256 roomId);

    constructor() ERC721("RTTA Achievement", "RTTA-ACH") Ownable(msg.sender) {
        // è®¾ç½®é»˜è®¤å…ƒæ•°æ®
        achievementMetadata["HUMAN_HUNTER"] = "ipfs://QmHumanHunter...";
        achievementMetadata["PERFECT_IMPOSTOR"] = "ipfs://QmPerfectImpostor...";
        achievementMetadata["LAST_HUMAN"] = "ipfs://QmLastHuman...";
        achievementMetadata["LIGHTNING_KILLER"] = "ipfs://QmLightningKiller...";
        achievementMetadata["IRON_WILL"] = "ipfs://QmIronWill...";
    }

    modifier onlyArena() {
        require(msg.sender == arenaContract, "Only arena can mint");
        _;
    }

    function setArenaContract(address _arena) external onlyOwner {
        arenaContract = _arena;
    }

    function mint(
        address _to,
        string calldata _achievementType,
        uint256 _roomId
    ) external onlyArena returns (uint256) {
        uint256 tokenId = _tokenIdCounter++;

        _safeMint(_to, tokenId);

        achievements[tokenId] = Achievement({
            achievementType: _achievementType,
            roomId: _roomId,
            timestamp: block.timestamp
        });

        emit AchievementMinted(_to, tokenId, _achievementType, _roomId);
        return tokenId;
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(ownerOf(tokenId) != address(0), "Token does not exist");
        return achievementMetadata[achievements[tokenId].achievementType];
    }

    function setAchievementMetadata(string calldata _type, string calldata _uri) external onlyOwner {
        achievementMetadata[_type] = _uri;
    }
}
```

### 5.3 Session Key éªŒè¯å™¨

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract SessionKeyValidator {

    struct Session {
        address owner;           // ä¸»é’±åŒ…åœ°å€
        uint256 expiresAt;       // è¿‡æœŸæ—¶é—´æˆ³
        uint256 maxUsage;        // æœ€å¤§ä½¿ç”¨æ¬¡æ•°
        uint256 usageCount;      // å½“å‰ä½¿ç”¨æ¬¡æ•°
        bool isRevoked;          // æ˜¯å¦å·²æ’¤é”€
    }

    mapping(address => Session) public sessions;

    event SessionCreated(address indexed sessionKey, address indexed owner, uint256 expiresAt);
    event SessionRevoked(address indexed sessionKey);

    modifier onlyValidSession(address _sessionKey) {
        require(isSessionValid(_sessionKey), "Invalid or expired session");
        _;
        // åœ¨å‡½æ•°æ‰§è¡ŒæˆåŠŸåæ‰é€’å¢ usageCount
        // å¦‚æœå‡½æ•° revertï¼ŒçŠ¶æ€ä¼šå›æ»šï¼ŒusageCount ä¸ä¼šå¢åŠ 
        sessions[_sessionKey].usageCount++;
    }

    function createSession(
        address _sessionKey,
        uint256 _duration,
        uint256 _maxUsage
    ) external {
        require(sessions[_sessionKey].owner == address(0), "Session already exists");

        sessions[_sessionKey] = Session({
            owner: msg.sender,
            expiresAt: block.timestamp + _duration,
            maxUsage: _maxUsage,
            usageCount: 0,
            isRevoked: false
        });

        emit SessionCreated(_sessionKey, msg.sender, block.timestamp + _duration);
    }

    function revokeSession(address _sessionKey) external {
        require(sessions[_sessionKey].owner == msg.sender, "Not session owner");
        sessions[_sessionKey].isRevoked = true;
        emit SessionRevoked(_sessionKey);
    }

    function isSessionValid(address _sessionKey) public view returns (bool) {
        Session storage session = sessions[_sessionKey];
        return (
            session.owner != address(0) &&
            block.timestamp <= session.expiresAt &&
            !session.isRevoked &&
            session.usageCount < session.maxUsage
        );
    }

    function getSessionRemainingTime(address _sessionKey) external view returns (uint256) {
        Session storage session = sessions[_sessionKey];
        if (block.timestamp >= session.expiresAt) return 0;
        return session.expiresAt - block.timestamp;
    }
}
```

---

## 6. MCP é€‚é…å™¨å±‚

### 6.1 ç›®å½•ç»“æ„

```
packages/mcp-adapter/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.ts              # MCP Server å…¥å£
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ getArenaStatus.ts # è·å–æˆ¿é—´çŠ¶æ€
â”‚   â”‚   â”œâ”€â”€ actionOnchain.ts  # æ‰§è¡Œé“¾ä¸Šæ“ä½œ
â”‚   â”‚   â””â”€â”€ sessionManager.ts # Session Key ç®¡ç†
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ monadClient.ts    # Monad RPC å®¢æˆ·ç«¯
â”‚   â”‚   â””â”€â”€ signer.ts         # äº¤æ˜“ç­¾åå™¨
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ index.ts          # ç±»å‹å®šä¹‰
â”œâ”€â”€ config/
â”‚   â””â”€â”€ default.json          # é»˜è®¤é…ç½®
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

### 6.2 MCP Server å®ç°

```typescript
// packages/mcp-adapter/src/index.ts

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { ethers } from "ethers";

// åˆå§‹åŒ– MCP Server
const server = new McpServer({
  name: "monad-arena",
  version: "1.0.0",
});

// Monad RPC è¿æ¥
const provider = new ethers.JsonRpcProvider(
  process.env.MONAD_RPC_URL || "https://testnet-rpc.monad.xyz"
);

// Session Key (ä»ç¯å¢ƒå˜é‡æˆ–å®‰å…¨å­˜å‚¨è·å–)
let sessionWallet: ethers.Wallet | null = null;

// åˆçº¦åœ°å€
const ARENA_CONTRACT = process.env.ARENA_CONTRACT_ADDRESS || "";

// åˆçº¦ ABI (ç®€åŒ–ç‰ˆ)
const ARENA_ABI = [
  "function getRoomInfo(uint256 roomId) view returns (tuple(uint256 id, uint256 entryFee, uint256 prizePool, uint256 startBlock, uint256 baseInterval, uint256 playerCount, uint256 aliveCount, bool isActive, bool isEnded, uint8 currentPhase))",
  "function getPlayerInfo(uint256 roomId, address player) view returns (tuple(address addr, string personaID, int256 humanityScore, int256 initialHumanityScore, bool isAlive, uint256 lastActionBlock, uint256 actionCount, uint256 successfulVotes, bool isVerifiedHuman))",
  "function getAllPlayers(uint256 roomId) view returns (address[])",
  "function sendMessage(uint256 roomId, string content)",
  "function castVote(uint256 roomId, address target)",
  "function joinRoom(uint256 roomId, string personaID) payable",
  "event NewMessage(uint256 indexed roomId, address indexed sender, string content, uint256 timestamp)",
  "event VoteCast(uint256 indexed roomId, address indexed voter, address indexed suspect)",
];

// ============ å·¥å…·å®šä¹‰ ============

// å·¥å…· 1: è·å–ç«æŠ€åœºçŠ¶æ€
server.tool(
  "get_arena_status",
  "è·å–å½“å‰å¤§é€ƒæ€æˆ¿é—´çš„å®æ—¶ä¸Šä¸‹æ–‡ï¼ˆå¯¹è¯å†å²ã€ç©å®¶æ€€ç–‘åº¦ã€å‰©ä½™æ—¶é—´ï¼‰",
  {
    roomId: z.string().describe("æˆ¿é—´ ID"),
  },
  async ({ roomId }) => {
    try {
      const contract = new ethers.Contract(ARENA_CONTRACT, ARENA_ABI, provider);

      // è·å–æˆ¿é—´å’Œç©å®¶ä¿¡æ¯
      const [roomInfo, players] = await Promise.all([
        contract.getRoomInfo(roomId),
        contract.getAllPlayers(roomId),
      ]);

      // é€šè¿‡äº‹ä»¶è·å–èŠå¤©è®°å½• (ä»æ¸¸æˆå¼€å§‹åŒºå—æŸ¥è¯¢)
      const startBlock = Number(roomInfo.startBlock);
      const currentBlock = await provider.getBlockNumber();

      const filter = contract.filters.NewMessage(roomId);
      // æŸ¥è¯¢ä»æ¸¸æˆå¼€å§‹åˆ°æœ€è¿‘çš„åŒºå—
      const events = await contract.queryFilter(
        filter,
        Math.max(0, currentBlock - 5000), // æœ€å¤šæŸ¥è¯¢æœ€è¿‘ 5000 ä¸ªåŒºå—
        currentBlock
      );
      const chatHistory = events.map((e: any) => ({
        sender: e.args.sender,
        content: e.args.content,
        timestamp: Number(e.args.timestamp),
      }));

      // è·å–æ‰€æœ‰ç©å®¶è¯¦ç»†ä¿¡æ¯
      const playerInfos = await Promise.all(
        players.map((addr: string) => contract.getPlayerInfo(roomId, addr))
      );

      const formattedPlayers = playerInfos.map((p: any) => ({
        address: p.addr,
        personaID: p.personaID,
        humanityScore: Number(p.humanityScore),
        isAlive: p.isAlive,
        actionCount: Number(p.actionCount),
        successfulVotes: Number(p.successfulVotes),
        isVerifiedHuman: p.isVerifiedHuman,
      }));

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              room: {
                id: roomInfo.id.toString(),
                prizePool: ethers.formatEther(roomInfo.prizePool),
                playerCount: Number(roomInfo.playerCount),
                aliveCount: Number(roomInfo.aliveCount),
                isActive: roomInfo.isActive,
                isEnded: roomInfo.isEnded,
                currentPhase: Number(roomInfo.currentPhase),
              },
              players: formattedPlayers,
              recentChat: chatHistory.slice(-20), // æœ€è¿‘ 20 æ¡æ¶ˆæ¯
            }, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error}` }],
        isError: true,
      };
    }
  }
);

// å·¥å…· 2: æ‰§è¡Œé“¾ä¸Šæ“ä½œ
server.tool(
  "action_onchain",
  "åœ¨é“¾ä¸Šæ‰§è¡ŒåŠ¨ä½œï¼šèŠå¤©ã€æŠ•ç¥¨ã€æˆ–åŠ å…¥æˆ¿é—´",
  {
    type: z.enum(["CHAT", "VOTE", "JOIN"]).describe("æ“ä½œç±»å‹"),
    roomId: z.string().describe("æˆ¿é—´ ID"),
    content: z.string().optional().describe("èŠå¤©å†…å®¹ï¼ˆCHAT æ—¶å¿…å¡«ï¼Œæœ€å¤š 280 å­—ç¬¦ï¼‰"),
    target: z.string().optional().describe("æŠ•ç¥¨ç›®æ ‡åœ°å€ï¼ˆVOTE æ—¶å¿…å¡«ï¼‰"),
    personaID: z.string().optional().describe("è§’è‰² IDï¼ˆJOIN æ—¶å¿…å¡«ï¼‰"),
    entryFee: z.string().optional().describe("å…¥åœºè´¹ ETH é‡‘é¢ï¼ˆJOIN æ—¶å¿…å¡«ï¼‰"),
  },
  async ({ type, roomId, content, target, personaID, entryFee }) => {
    if (!sessionWallet) {
      return {
        content: [{ type: "text", text: "Error: Session Key not initialized" }],
        isError: true,
      };
    }

    try {
      const contract = new ethers.Contract(
        ARENA_CONTRACT,
        ARENA_ABI,
        sessionWallet
      );

      let tx;

      switch (type) {
        case "CHAT":
          if (!content) throw new Error("Content required for CHAT");
          if (content.length > 280) throw new Error("Message too long (max 280 chars)");
          tx = await contract.sendMessage(roomId, content);
          break;

        case "VOTE":
          if (!target) throw new Error("Target required for VOTE");
          tx = await contract.castVote(roomId, target);
          break;

        case "JOIN":
          if (!personaID || !entryFee) {
            throw new Error("PersonaID and entryFee required for JOIN");
          }
          tx = await contract.joinRoom(roomId, personaID, {
            value: ethers.parseEther(entryFee),
          });
          break;
      }

      await tx.wait();

      return {
        content: [
          {
            type: "text",
            text: `âœ… Action ${type} executed successfully!\nTx Hash: ${tx.hash}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error}` }],
        isError: true,
      };
    }
  }
);

// å·¥å…· 3: æ£€æŸ¥ Session Key çŠ¶æ€
server.tool(
  "check_session_status",
  "æ£€æŸ¥å½“å‰ Session Key çš„å‰©ä½™æ—¶é—´å’Œä½¿ç”¨æ¬¡æ•°",
  {},
  async () => {
    if (!sessionWallet) {
      return {
        content: [{ type: "text", text: "Session Key not initialized" }],
        isError: true,
      };
    }

    try {
      const contract = new ethers.Contract(ARENA_CONTRACT, [
        "function getSessionRemainingTime(address) view returns (uint256)",
        "function sessions(address) view returns (address owner, uint256 expiresAt, uint256 maxUsage, uint256 usageCount, bool isRevoked)",
      ], provider);

      const remaining = await contract.getSessionRemainingTime(sessionWallet.address);
      const session = await contract.sessions(sessionWallet.address);

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              sessionKey: sessionWallet.address,
              remainingSeconds: Number(remaining),
              remainingMinutes: Math.floor(Number(remaining) / 60),
              usageCount: Number(session.usageCount),
              maxUsage: Number(session.maxUsage),
              isValid: Number(remaining) > 0 && !session.isRevoked,
            }, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error}` }],
        isError: true,
      };
    }
  }
);

// å·¥å…· 4: åˆå§‹åŒ– Session Key
server.tool(
  "init_session",
  "åˆå§‹åŒ–æˆ–æ›´æ–° Session Key",
  {
    privateKey: z.string().describe("Session Key çš„ç§é’¥ï¼ˆä¸´æ—¶å¯†é’¥ï¼‰"),
  },
  async ({ privateKey }) => {
    try {
      sessionWallet = new ethers.Wallet(privateKey, provider);
      return {
        content: [
          {
            type: "text",
            text: `âœ… Session initialized!\nAddress: ${sessionWallet.address}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error}` }],
        isError: true,
      };
    }
  }
);

// å¯åŠ¨æœåŠ¡å™¨
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Monad Arena MCP Server running...");
}

main().catch(console.error);
```

### 6.3 MCP æŠ€èƒ½å®šä¹‰ (JSON Schema)

```json
{
  "tools": [
    {
      "name": "get_arena_status",
      "description": "è·å–å½“å‰å¤§é€ƒæ€æˆ¿é—´çš„å®æ—¶ä¸Šä¸‹æ–‡ï¼ˆå¯¹è¯å†å²ã€ç©å®¶çŠ¶æ€ã€æ¸¸æˆè¿›åº¦ï¼‰",
      "input_schema": {
        "type": "object",
        "properties": {
          "roomId": {
            "type": "string",
            "description": "æˆ¿é—´ ID"
          }
        },
        "required": ["roomId"]
      }
    },
    {
      "name": "action_onchain",
      "description": "åœ¨é“¾ä¸Šæ‰§è¡ŒåŠ¨ä½œï¼šèŠå¤©ã€æŠ•ç¥¨ã€æˆ–åŠ å…¥æˆ¿é—´",
      "input_schema": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": ["CHAT", "VOTE", "JOIN"],
            "description": "æ“ä½œç±»å‹"
          },
          "roomId": {
            "type": "string",
            "description": "æˆ¿é—´ ID"
          },
          "content": {
            "type": "string",
            "description": "èŠå¤©å†…å®¹ï¼ˆCHAT æ—¶å¿…å¡«ï¼Œæœ€å¤š 280 å­—ç¬¦ï¼‰"
          },
          "target": {
            "type": "string",
            "description": "æŠ•ç¥¨ç›®æ ‡åœ°å€ï¼ˆVOTE æ—¶å¿…å¡«ï¼‰"
          },
          "personaID": {
            "type": "string",
            "description": "è§’è‰² IDï¼ˆJOIN æ—¶å¿…å¡«ï¼‰"
          },
          "entryFee": {
            "type": "string",
            "description": "å…¥åœºè´¹ MON é‡‘é¢ï¼ˆJOIN æ—¶å¿…å¡«ï¼Œå¦‚ 0.01ï¼‰"
          }
        },
        "required": ["type", "roomId"]
      }
    },
    {
      "name": "check_session_status",
      "description": "æ£€æŸ¥å½“å‰ Session Key çš„å‰©ä½™æ—¶é—´å’Œä½¿ç”¨æ¬¡æ•°",
      "input_schema": {
        "type": "object",
        "properties": {}
      }
    },
    {
      "name": "init_session",
      "description": "åˆå§‹åŒ–æˆ–æ›´æ–° Session Key",
      "input_schema": {
        "type": "object",
        "properties": {
          "privateKey": {
            "type": "string",
            "description": "Session Key çš„ç§é’¥ï¼ˆä¸´æ—¶å¯†é’¥ï¼‰"
          }
        },
        "required": ["privateKey"]
      }
    },
    {
      "name": "get_game_phases",
      "description": "è·å–å½“å‰æ¸¸æˆçš„ Phase ä¿¡æ¯å’Œæ¯’åœˆçŠ¶æ€",
      "input_schema": {
        "type": "object",
        "properties": {
          "roomId": {
            "type": "string",
            "description": "æˆ¿é—´ ID"
          }
        },
        "required": ["roomId"]
      }
    }
  ]
}
```

### 6.4 Claude Desktop é…ç½®

```json
// ~/.config/Claude/claude_desktop_config.json (Linux)
// ~/Library/Application Support/Claude/claude_desktop_config.json (macOS)

{
  "mcpServers": {
    "monad-arena": {
      "command": "node",
      "args": ["/path/to/packages/mcp-adapter/dist/index.js"],
      "env": {
        "MONAD_RPC_URL": "https://testnet-rpc.monad.xyz",
        "ARENA_CONTRACT_ADDRESS": "0x...",
        "SESSION_PRIVATE_KEY": "0x..."
      }
    }
  }
}
```

---

## 7. Session Key å®‰å…¨ä½“ç³»

### 7.1 å®‰å…¨æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ç”¨æˆ·ä¸»é’±åŒ… (EOA)                         â”‚
â”‚                    - ç§é’¥æ°¸ä¸ç¦»çº¿                            â”‚
â”‚                    - ä»…ç”¨äºæˆæƒ Session Key                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ ç­¾åæˆæƒ
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Session Key (ä¸´æ—¶é’±åŒ…)                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ æƒé™é™åˆ¶ (Policy)                                    â”‚   â”‚
â”‚  â”‚ - æœ‰æ•ˆæœŸ: 1-2 å°æ—¶                                   â”‚   â”‚
â”‚  â”‚ - æœ€å¤§æ“ä½œæ¬¡æ•°: 100 æ¬¡                               â”‚   â”‚
â”‚  â”‚ - ä»…èƒ½ä¸ Arena åˆçº¦äº¤äº’                              â”‚   â”‚
â”‚  â”‚ - æœ€å¤§èµ„é‡‘åŠ¨ç”¨: 10 MON                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚ å­˜å‚¨äº
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   MCP Server (æœ¬åœ°è¿è¡Œ)                      â”‚
â”‚  - å†…å­˜å­˜å‚¨ï¼Œä¸æŒä¹…åŒ–                                        â”‚
â”‚  - å¯é€‰: TEE éš”ç¦»                                           â”‚
â”‚  - è¿›ç¨‹ç»“æŸå³é”€æ¯                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.2 Session Key ç”Ÿå‘½å‘¨æœŸ

| é˜¶æ®µ | æ“ä½œ | å®‰å…¨è€ƒé‡ |
|------|------|----------|
| åˆ›å»º | å‰ç«¯ç”Ÿæˆéšæœºå¯†é’¥å¯¹ | ä½¿ç”¨ crypto.getRandomValues() |
| æˆæƒ | ä¸»é’±åŒ…ç­¾åæˆæƒäº¤æ˜“ | è®¾ç½®æœ‰æ•ˆæœŸå’Œä½¿ç”¨ä¸Šé™ |
| ä½¿ç”¨ | MCP Server è‡ªåŠ¨ç­¾å | æ¯æ¬¡ä½¿ç”¨è®¡æ•° +1 |
| ç»­æœŸ | å‰ç«¯è§¦å‘ä¸»é’±åŒ…é‡ç­¾ | äººæ€§åˆ†é«˜äº 80 å¯è‡ªåŠ¨æç¤º |
| é”€æ¯ | è¿‡æœŸ/æ’¤é”€/è¿›ç¨‹é€€å‡º | é“¾ä¸ŠçŠ¶æ€æ ‡è®°ä¸º revoked |

### 7.3 å‰ç«¯æˆæƒæµç¨‹

```typescript
// packages/nextjs/components/SessionKeyManager.tsx

import { useAccount, useSignMessage } from "wagmi";
import { ethers } from "ethers";

export function SessionKeyManager() {
  const { address } = useAccount();
  const { signMessageAsync } = useSignMessage();

  const createSessionKey = async () => {
    // 1. ç”Ÿæˆä¸´æ—¶å¯†é’¥å¯¹
    const sessionWallet = ethers.Wallet.createRandom();

    // 2. æ„é€ æˆæƒæ¶ˆæ¯
    const message = JSON.stringify({
      type: "RTTA_SESSION_AUTH",
      sessionKey: sessionWallet.address,
      owner: address,
      expiresAt: Math.floor(Date.now() / 1000) + 7200, // 2å°æ—¶
      maxUsage: 100,
      allowedContract: ARENA_CONTRACT_ADDRESS,
    });

    // 3. ä¸»é’±åŒ…ç­¾å
    const signature = await signMessageAsync({ message });

    // 4. å‘é€åˆ°é“¾ä¸Šæ³¨å†Œ
    // ... è°ƒç”¨åˆçº¦ createSession()

    // 5. å°† Session Key ä¼ é€’ç»™ MCP Server
    // æ³¨æ„: ç§é’¥åªåœ¨ç”¨æˆ·è®¾å¤‡ä¸Šå¤„ç†ï¼Œä¸ä¸Šä¼ åˆ°ä»»ä½•æœåŠ¡å™¨
    return {
      publicKey: sessionWallet.address,
      privateKey: sessionWallet.privateKey, // ä»…æœ¬åœ°ä½¿ç”¨
    };
  };

  return (
    <button onClick={createSessionKey} className="btn btn-primary">
      Generate Session Key
    </button>
  );
}
```

---

## 8. å‰ç«¯å®ç°æ–¹æ¡ˆ

### 8.1 è§†è§‰è®¾è®¡åŸåˆ™

| åŸåˆ™ | å®ç°æ–¹å¼ |
|------|----------|
| **èµ›åšæœ‹å…‹** | é»‘è‰²èƒŒæ™¯ + è§å…‰è“/ç»¿/ç´« é«˜å¯¹æ¯”åº¦ |
| **æ•°æ®æµæ„Ÿ** | å®æ—¶æ»šåŠ¨çš„äº¤æ˜“å“ˆå¸Œã€äºŒè¿›åˆ¶é›¨æ•ˆæœ |
| **ç»ˆç«¯äº¤äº’** | å‘½ä»¤è¡Œé£æ ¼è¾“å…¥æ¡†ï¼Œtyping éŸ³æ•ˆ |
| **å‹è¿«æ„Ÿ** | å®æ—¶å€’è®¡æ—¶ã€ç†µå€¼æ³¢åŠ¨å›¾ã€å…¨å± Glitch æ•ˆæœ |
| **å“åº”å¼** | ç§»åŠ¨ç«¯é€‚é…ï¼Œæ ¸å¿ƒåŠŸèƒ½åœ¨æ‰‹æœºä¸Šå¯ç”¨ |

### 8.2 æ ¸å¿ƒç»„ä»¶æ¶æ„

```
packages/nextjs/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ page.tsx                          # Lobby å¤§å…é¡µé¢ (8.20)
â”‚   â”œâ”€â”€ _components/
â”‚   â”‚   â”œâ”€â”€ HeroSection.tsx               # é¦–é¡µ Hero åŒºåŸŸ (8.20.1)
â”‚   â”‚   â”œâ”€â”€ RoomCard.tsx                  # æˆ¿é—´å¡ç‰‡ (8.20.2)
â”‚   â”‚   â””â”€â”€ CreateRoomModal.tsx           # åˆ›å»ºæˆ¿é—´å¼¹çª— (8.20.3)
â”‚   â”œâ”€â”€ arena/
â”‚   â”‚   â”œâ”€â”€ page.tsx                      # ç«æŠ€åœºä¸»é¡µé¢ (8.14)
â”‚   â”‚   â”œâ”€â”€ _components/
â”‚   â”‚   â”‚   â”œâ”€â”€ ArenaTerminal.tsx         # ç»ˆç«¯å¼äº¤äº’ç•Œé¢ (8.11)
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerRadar.tsx           # é›·è¾¾æ‰«æåŠ¨ç”» (8.7)
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerList.tsx            # ç©å®¶åˆ—è¡¨
â”‚   â”‚   â”‚   â”œâ”€â”€ VotePanel.tsx             # æŠ•ç¥¨é¢æ¿ (8.6)
â”‚   â”‚   â”‚   â”œâ”€â”€ PhaseTimer.tsx            # Phase å€’è®¡æ—¶ (8.5)
â”‚   â”‚   â”‚   â”œâ”€â”€ SessionKeyManager.tsx     # Session Key ç®¡ç† (8.4)
â”‚   â”‚   â”‚   â”œâ”€â”€ TransactionFeed.tsx       # å®æ—¶äº¤æ˜“æµ
â”‚   â”‚   â”‚   â”œâ”€â”€ HumanityGauge.tsx         # äººæ€§åˆ†ä»ªè¡¨ç›˜
â”‚   â”‚   â”‚   â”œâ”€â”€ GlitchOverlay.tsx         # æ·˜æ±°æ•…éšœæ•ˆæœ (8.10)
â”‚   â”‚   â”‚   â”œâ”€â”€ LoadingScreen.tsx         # åŠ è½½åŠ¨ç”» (8.9)
â”‚   â”‚   â”‚   â”œâ”€â”€ ErrorBoundary.tsx         # é”™è¯¯è¾¹ç•Œ (8.8)
â”‚   â”‚   â”‚   â”œâ”€â”€ GameCountdown.tsx         # å¼€å±€å€’è®¡æ—¶ (8.21)
â”‚   â”‚   â”‚   â”œâ”€â”€ PhaseTransition.tsx       # Phase åˆ‡æ¢è¿‡æ¸¡ (8.22)
â”‚   â”‚   â”‚   â”œâ”€â”€ VictoryScreen.tsx         # èƒœåˆ©ç»“ç®—ç”»é¢ (8.23)
â”‚   â”‚   â”‚   â”œâ”€â”€ KillFeed.tsx             # å®æ—¶æ·˜æ±°é€šçŸ¥ (8.24)
â”‚   â”‚   â”‚   â”œâ”€â”€ GameHUD.tsx              # é¡¶éƒ¨çŠ¶æ€æ  (8.25)
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatMessage.tsx          # æ¶ˆæ¯ç±»å‹ç»„ä»¶ (8.26)
â”‚   â”‚   â”‚   â”œâ”€â”€ VotingGraph.tsx          # æŠ•ç¥¨å…³ç³»å›¾ (8.27)
â”‚   â”‚   â”‚   â”œâ”€â”€ DataStream.tsx           # é“¾ä¸Šäº¤æ˜“æµ (8.28)
â”‚   â”‚   â”‚   â”œâ”€â”€ PlayerIdentityCard.tsx   # ç©å®¶èº«ä»½å¡ (8.29)
â”‚   â”‚   â”‚   â”œâ”€â”€ ParticleBackground.tsx   # ç²’å­èƒŒæ™¯ (8.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ MatrixRain.tsx           # çŸ©é˜µé›¨ (8.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ CyberTitle.tsx           # èµ›åšæ ‡é¢˜ (8.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ NeonBorder.tsx           # éœ“è™¹è¾¹æ¡† (8.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ PulseCard.tsx            # è„‰å†²å¡ç‰‡ (8.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ FlipNumber.tsx           # ç¿»è½¬æ•°å­— (8.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ HolographicCard.tsx      # å…¨æ¯å¡ç‰‡ (8.13)
â”‚   â”‚   â”‚   â”œâ”€â”€ GlitchText.tsx           # æ•…éšœæ–‡å­— (8.13)
â”‚   â”‚   â”‚   â””â”€â”€ SoundIndicator.tsx       # éŸ³æ•ˆæç¤º (8.15)
â”‚   â”‚   â”œâ”€â”€ _hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useArenaState.ts         # ç«æŠ€åœºçŠ¶æ€ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ useRealtimeChat.ts       # WebSocket èŠå¤©
â”‚   â”‚   â”‚   â”œâ”€â”€ usePlayerStatus.ts       # ç©å®¶å­˜æ´»çŠ¶æ€
â”‚   â”‚   â”‚   â””â”€â”€ useEntropyTracker.ts     # ç†µå€¼è¿½è¸ª
â”‚   â”‚   â””â”€â”€ _styles/
â”‚   â”‚       â””â”€â”€ cyberpunk.css            # èµ›åšæœ‹å…‹ä¸»é¢˜
â”‚   â””â”€â”€ globals.css                       # å…¨å±€ CSS + èµ›åšæœ‹å…‹ä¸»é¢˜ (8.30)
â””â”€â”€ services/
    â””â”€â”€ store/
        â””â”€â”€ gameStore.ts                  # Zustand æ¸¸æˆçŠ¶æ€ (8.19)
```

### 8.3 æ–°å¢ MCP å·¥å…·: è·å–æ¸¸æˆ Phase ä¿¡æ¯

```typescript
// å·¥å…· 5: è·å–æ¸¸æˆ Phase ä¿¡æ¯
server.tool(
  "get_game_phases",
  "è·å–å½“å‰æ¸¸æˆçš„ Phase ä¿¡æ¯å’Œæ¯’åœˆçŠ¶æ€",
  {
    roomId: z.string().describe("æˆ¿é—´ ID"),
  },
  async ({ roomId }) => {
    try {
      const contract = new ethers.Contract(ARENA_CONTRACT, ARENA_ABI, provider);
      const roomInfo = await contract.getRoomInfo(roomId);
      const currentBlock = await provider.getBlockNumber();

      // è®¡ç®—å‰©ä½™æ—¶é—´
      const blocksUntilNextRound = Number(roomInfo.lastDecayBlock) + Number(roomInfo.currentInterval) - currentBlock;
      const secondsUntilNextRound = blocksUntilNextRound * 0.4; // Monad 0.4s å‡ºå—

      // è®¡ç®—å½“å‰ Phase
      const alivePercent = (Number(roomInfo.aliveCount) * 100) / Number(roomInfo.playerCount);
      let currentPhase = 1;
      let phaseName = "Phase 1: æ¢ç´¢æœŸ";
      if (alivePercent <= 33) {
        currentPhase = 3;
        phaseName = "Phase 3: ç»ˆå±€å†³æˆ˜";
      } else if (alivePercent <= 67) {
        currentPhase = 2;
        phaseName = "Phase 2: ç™½çƒ­åŒ–";
      }

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              roomId,
              currentPhase,
              phaseName,
              alivePercent: Math.round(alivePercent),
              playerCount: Number(roomInfo.playerCount),
              aliveCount: Number(roomInfo.aliveCount),
              eliminatedCount: Number(roomInfo.playerCount) - Number(roomInfo.aliveCount),
              secondsUntilNextRound: Math.max(0, secondsUntilNextRound),
              currentDecay: Number(roomInfo.currentDecay || 0),
              isActive: roomInfo.isActive,
              isEnded: roomInfo.isEnded,
            }, null, 2),
          },
        ],
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error}` }],
        isError: true,
      };
    }
  }
);
```

### 8.4 æ–°å¢ç»„ä»¶: Session Key ç®¡ç†å™¨

```tsx
// packages/nextjs/app/arena/_components/SessionKeyManager.tsx

"use client";

import { useState } from "react";
import { useAccount, useSignMessage } from "wagmi";
import { ethers } from "ethers";
import { useScaffoldWriteContract } from "~~/hooks/scaffold-eth";

export function SessionKeyManager({ roomId }: { roomId: string }) {
  const { address, isConnected } = useAccount();
  const { signMessageAsync } = useSignMessage();
  const { writeContractAsync } = useScaffoldWriteContract({ contractName: "TuringArena" });

  const [sessionKey, setSessionKey] = useState<{ address: string; privateKey: string } | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  const createSessionKey = async () => {
    if (!address) return;

    setIsCreating(true);
    try {
      // 1. ç”Ÿæˆä¸´æ—¶å¯†é’¥å¯¹
      const wallet = ethers.Wallet.createRandom();

      // 2. æ„é€ æˆæƒæ¶ˆæ¯
      const message = JSON.stringify({
        type: "RTTA_SESSION_AUTH",
        sessionKey: wallet.address,
        owner: address,
        expiresAt: Math.floor(Date.now() / 1000) + 7200, // 2å°æ—¶
        maxUsage: 100,
        allowedContract: process.env.NEXT_PUBLIC_ARENA_CONTRACT,
      });

      // 3. ä¸»é’±åŒ…ç­¾å
      const signature = await signMessageAsync({ message });

      // 4. å‘é€åˆ°é“¾ä¸Šæ³¨å†Œ
      await writeContractAsync({
        functionName: "createSession",
        args: [wallet.address, 7200, 100],
      });

      setSessionKey({
        address: wallet.address,
        privateKey: wallet.privateKey,
      });

      // æç¤ºç”¨æˆ·å°†ç§é’¥å¤åˆ¶åˆ° MCP é…ç½®
      alert(`Session Key created!\nAddress: ${wallet.address}\n\nCopy this private key to your MCP config:\n${wallet.privateKey}`);
    } catch (error) {
      console.error("Failed to create session key:", error);
    } finally {
      setIsCreating(false);
    }
  };

  if (!isConnected) {
    return (
      <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-lg p-4 text-center">
        <p className="text-yellow-400 font-mono">Connect wallet to enable AI participation</p>
      </div>
    );
  }

  return (
    <div className="bg-black/50 border border-purple-500/30 rounded-lg p-4">
      <h3 className="text-purple-400 font-mono text-sm mb-3 flex items-center gap-2">
        <span className="w-2 h-2 rounded-full bg-purple-500 animate-pulse" />
        AI SESSION KEY
      </h3>

      {sessionKey ? (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-gray-400 font-mono text-xs">Session Address:</span>
            <span className="text-green-400 font-mono text-xs">
              {sessionKey.address.slice(0, 6)}...{sessionKey.address.slice(-4)}
            </span>
          </div>
          <div className="flex items-center gap-2">
            <div className="flex-1 bg-gray-800 rounded px-3 py-2">
              <code className="text-gray-500 text-xs break-all">
                {sessionKey.privateKey.slice(0, 20)}...{sessionKey.privateKey.slice(-10)}
              </code>
            </div>
            <button
              onClick={() => navigator.clipboard.writeText(sessionKey.privateKey)}
              className="btn btn-xs btn-secondary"
            >
              Copy
            </button>
          </div>
        </div>
      ) : (
        <button
          onClick={createSessionKey}
          disabled={isCreating}
          className="w-full btn btn-outline btn-primary btn-sm"
        >
          {isCreating ? (
            <span className="loading loading-spinner loading-xs"></span>
          ) : (
            "Generate Session Key for AI"
          )}
        </button>
      )}
    </div>
  );
}
```

### 8.5 æ–°å¢ç»„ä»¶: Phase å€’è®¡æ—¶

```tsx
// packages/nextjs/app/arena/_components/PhaseTimer.tsx

"use client";

import { useEffect, useState } from "react";
import { useScaffoldReadContract } from "~~/hooks/scaffold-eth";

type PhaseInfo = {
  currentPhase: number;
  phaseName: string;
  secondsUntilNextRound: number;
  blocksUntilNextRound: number;
  decayValue: number;
};

export function PhaseTimer({ roomId }: { roomId: string }) {
  const [timeLeft, setTimeLeft] = useState(0);
  const [phaseInfo, setPhaseInfo] = useState<PhaseInfo | null>(null);

  const { data: roomInfo } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "getRoomInfo",
    args: [BigInt(roomId)],
  });

  useEffect(() => {
    if (!roomInfo) return;

    const calculateTimeLeft = () => {
      // å‡è®¾ Monad å‡ºå—æ—¶é—´ 0.4 ç§’
      const currentInterval = Number(roomInfo.currentInterval);
      const lastDecayBlock = Number(roomInfo.lastDecayBlock);
      // è¿™é‡Œéœ€è¦è·å–å½“å‰åŒºå—å·ï¼Œç®€åŒ–å¤„ç†ä½¿ç”¨ timestamp
      const blocksRemaining = Math.max(0, currentInterval - 60); // å‡è®¾å·²è¿‡ 60 åŒºå—
      setTimeLeft(blocksRemaining * 0.4);
    };

    calculateTimeLeft();
    const interval = setInterval(calculateTimeLeft, 1000);

    return () => clearInterval(interval);
  }, [roomInfo]);

  useEffect(() => {
    if (!roomInfo) return;

    const aliveCount = Number(roomInfo.aliveCount);
    const playerCount = Number(roomInfo.playerCount);
    const alivePercent = (aliveCount * 100) / playerCount;

    let currentPhase = 1;
    let phaseName = "PHASE 1: EXPLORATION";
    // ä»åˆçº¦è¯»å–å®é™…è¡°å‡å€¼
    const decayValue = Number(roomInfo.currentDecay ?? 0);

    if (alivePercent <= 33) {
      currentPhase = 3;
      phaseName = "PHASE 3: FINAL SHOWDOWN";
    } else if (alivePercent <= 67) {
      currentPhase = 2;
      phaseName = "PHASE 2: HEAT UP";
    }

    setPhaseInfo({ currentPhase, phaseName, secondsUntilNextRound: timeLeft, blocksUntilNextRound: Math.ceil(timeLeft / 0.4), decayValue });
  }, [roomInfo, timeLeft]);

  if (!phaseInfo) {
    return (
      <div className="h-16 bg-gray-900/50 border border-gray-700 rounded-lg flex items-center justify-center">
        <span className="loading loading-spinner loading-sm"></span>
      </div>
    );
  }

  const phaseColors = {
    1: "from-blue-500/20 to-blue-600/10 border-blue-500/30",
    2: "from-yellow-500/20 to-orange-600/10 border-yellow-500/30",
    3: "from-red-500/20 to-red-600/10 border-red-500/30",
  };

  return (
    <div className={`bg-gradient-to-r ${phaseColors[phaseInfo.currentPhase as keyof typeof phaseColors]} border rounded-lg p-4`}>
      <div className="flex items-center justify-between">
        <div>
          <div className="text-xs font-mono text-gray-400 mb-1">CURRENT PHASE</div>
          <div className="text-lg font-bold font-mono tracking-wider">
            {phaseInfo.phaseName}
          </div>
        </div>

        <div className="text-right">
          <div className="text-xs font-mono text-gray-400 mb-1">NEXT ROUND IN</div>
          <div className={`text-2xl font-mono font-bold ${timeLeft < 10 ? "text-red-500 animate-pulse" : "text-green-400"}`}>
            {Math.floor(timeLeft)}s
          </div>
        </div>
      </div>

      {phaseInfo.decayValue !== 0 && (
        <div className="mt-2 pt-2 border-t border-white/10 flex items-center gap-2">
          <span className="text-xs font-mono text-red-400">âš ï¸ TOXIN RING ACTIVE</span>
          <span className="text-xs font-mono text-gray-400">
            -{Math.abs(phaseInfo.decayValue)} HP/round
          </span>
        </div>
      )}

      {/* è¿›åº¦æ¡ */}
      <div className="mt-3 h-1 bg-gray-800 rounded-full overflow-hidden">
        <div
          className={`h-full transition-all duration-1000 ${
            phaseInfo.currentPhase === 1
              ? "bg-blue-500"
              : phaseInfo.currentPhase === 2
              ? "bg-yellow-500"
              : "bg-red-500"
          }`}
          style={{ width: `${100 - (timeLeft / 60) * 100}%` }}
        />
      </div>
    </div>
  );
}
```

### 8.6 æ–°å¢ç»„ä»¶: æŠ•ç¥¨é¢æ¿

```tsx
// packages/nextjs/app/arena/_components/VotePanel.tsx

"use client";

import { useState } from "react";
import { motion } from "framer-motion";
import { useScaffoldWriteContract, useScaffoldReadContract } from "~~/hooks/scaffold-eth";
import { Address } from "@scaffold-ui/components";

type Player = {
  address: string;
  personaId: string;
  humanityScore: number;
  isAlive: boolean;
  isVerifiedHuman: boolean;
  hasVoted: boolean;
};

export function VotePanel({ roomId, currentAddress }: { roomId: string; currentAddress: string }) {
  const [selectedTarget, setSelectedTarget] = useState<string | null>(null);
  const [isVoting, setIsVoting] = useState(false);

  const { data: players } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "getAllPlayers",
    args: [BigInt(roomId)],
  });

  const { data: currentRound } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "currentRound",
    args: [BigInt(roomId)],
  });

  const { writeContractAsync } = useScaffoldWriteContract({ contractName: "TuringArena" });

  // è·å–ç©å®¶è¯¦ç»†ä¿¡æ¯
  // TODO: å®é™…å®ç°ä¸­åº”æ‰¹é‡è°ƒç”¨ getPlayerInfoï¼Œæˆ–é€šè¿‡ multicall è·å–
  const playerList: Player[] = (players || []).map((addr: string) => ({
    address: addr as string,
    personaId: addr.slice(0, 8),
    humanityScore: 100, // TODO: ä» getPlayerInfo è·å–çœŸå®æ•°æ®
    isAlive: true,      // TODO: ä» getPlayerInfo è·å–çœŸå®æ•°æ®
    isVerifiedHuman: false,
    hasVoted: false,
  }));

  const alivePlayers = playerList.filter((p) => p.isAlive && p.address !== currentAddress);

  const handleVote = async () => {
    if (!selectedTarget || isVoting) return;

    setIsVoting(true);
    try {
      await writeContractAsync({
        functionName: "castVote",
        args: [BigInt(roomId), selectedTarget as `0x${string}`],
      });
      setSelectedTarget(null);
    } catch (error) {
      console.error("Vote failed:", error);
    } finally {
      setIsVoting(false);
    }
  };

  return (
    <div className="bg-black/80 border border-red-500/30 rounded-lg p-4">
      <h3 className="text-red-400 font-mono text-sm mb-4 flex items-center gap-2">
        <span className="w-2 h-2 rounded-full bg-red-500 animate-pulse" />
        VOTE PANEL - ROUND #{currentRound?.toString() || "1"}
      </h3>

      <div className="grid grid-cols-2 md:grid-cols-3 gap-2 max-h-64 overflow-y-auto">
        {alivePlayers.map((player) => (
          <motion.button
            key={player.address}
            whileHover={{ scale: 1.02 }}
            whileTap={{ scale: 0.98 }}
            onClick={() => setSelectedTarget(player.address)}
            className={`
              border rounded-lg p-3 text-left transition-all
              ${selectedTarget === player.address
                ? "border-red-500 bg-red-500/20"
                : "border-gray-700 bg-gray-900/50 hover:border-gray-600"
              }
            `}
          >
            <div className="flex items-center justify-between mb-1">
              <span className="text-xs font-mono text-gray-400 truncate">
                {player.personaId}
              </span>
              {player.isVerifiedHuman && (
                <span className="text-xs text-blue-400">âœ“ Human</span>
              )}
            </div>
            <div className="flex items-center gap-2">
              <Address address={player.address as `0x${string}`} size="xs" />
            </div>
            <div className="mt-1">
              <div className="flex items-center gap-1">
                <span className="text-xs text-gray-500">HP:</span>
                <div className="flex-1 h-1 bg-gray-800 rounded-full overflow-hidden">
                  <div
                    className={`h-full ${player.humanityScore > 50 ? "bg-green-500" : player.humanityScore > 25 ? "bg-yellow-500" : "bg-red-500"}`}
                    style={{ width: `${player.humanityScore}%` }}
                  />
                </div>
                <span className="text-xs font-mono text-gray-400">{player.humanityScore}</span>
              </div>
            </div>
          </motion.button>
        ))}
      </div>

      <div className="mt-4 flex gap-2">
        <button
          onClick={handleVote}
          disabled={!selectedTarget || isVoting}
          className="flex-1 btn btn-error btn-sm"
        >
          {isVoting ? (
            <span className="loading loading-spinner loading-xs"></span>
          ) : (
            `VOTE ${selectedTarget ? "â†’ " + selectedTarget.slice(0, 6) : ""}`
          )}
        </button>
      </div>

      <div className="mt-2 text-xs font-mono text-gray-500 text-center">
        âš ï¸ Voting deals 5 damage. Skipping deals 10 damage to yourself.
      </div>
    </div>
  );
}
```

### 8.7 ä¼˜åŒ–åçš„ PlayerRadar ç»„ä»¶ (å¸¦ç©å®¶æ ‡è¯†)

```tsx
// packages/nextjs/app/arena/_components/PlayerRadar.tsx

"use client";

import { useEffect, useRef, useState } from "react";
import { useScaffoldReadContract } from "~~/hooks/scaffold-eth";

type Player = {
  address: string;
  personaId: string;
  humanityScore: number;
  isAlive: boolean;
  isVerifiedHuman: boolean;
};

export function PlayerRadar({ roomId }: { roomId: string }) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [hoveredPlayer, setHoveredPlayer] = useState<Player | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  // ä»åˆçº¦è·å–ç©å®¶åˆ—è¡¨
  const { data: playerAddresses } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "getAllPlayers",
    args: [BigInt(roomId)],
  });

  // TODO: å®é™…å®ç°ä¸­éœ€è¦æ‰¹é‡è°ƒç”¨ getPlayerInfo è·å–æ¯ä¸ªç©å®¶è¯¦ç»†æ•°æ®
  // è¿™é‡Œç®€åŒ–ä¸ºä»åœ°å€åˆ—è¡¨æ„å»ºç©å®¶æ•°ç»„
  const players: Player[] = (playerAddresses || []).map((addr: string) => ({
    address: addr,
    personaId: addr.slice(0, 8),
    humanityScore: 100,
    isAlive: true,
    isVerifiedHuman: false,
  }));

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    let animationId: number;
    let angle = 0;

    const draw = () => {
      ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 20;

      // ç»˜åˆ¶é›·è¾¾åœ†ç¯
      ctx.strokeStyle = "rgba(0, 255, 100, 0.3)";
      ctx.lineWidth = 1;
      for (let i = 1; i <= 4; i++) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, (radius / 4) * i, 0, Math.PI * 2);
        ctx.stroke();
      }

      // ç»˜åˆ¶æ‰«æçº¿
      ctx.strokeStyle = "rgba(0, 255, 100, 0.8)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(
        centerX + Math.cos(angle) * radius,
        centerY + Math.sin(angle) * radius
      );
      ctx.stroke();

      // ç»˜åˆ¶ç©å®¶ç‚¹
      players.forEach((player, index) => {
        if (!player.isAlive) return;

        const playerAngle = (index / players.length) * Math.PI * 2;
        const distance = ((100 - player.humanityScore) / 100) * radius;

        const x = centerX + Math.cos(playerAngle) * distance;
        const y = centerY + Math.sin(playerAngle) * distance;

        // é¢œè‰²æ ¹æ®äººæ€§åˆ†å˜åŒ–
        const hue = player.humanityScore; // 0=çº¢, 100=ç»¿
        ctx.fillStyle = player.isVerifiedHuman
          ? `hsl(220, 100%, 60%)`  // è“è‰²è¡¨ç¤ºçœŸäºº
          : `hsl(${hue}, 100%, 50%)`;

        ctx.beginPath();
        ctx.arc(x, y, 8, 0, Math.PI * 2);
        ctx.fill();

        // ç»˜åˆ¶ç©å®¶æ ‡ç­¾
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.font = "10px monospace";
        ctx.fillText(player.personaId.slice(0, 6), x + 12, y + 4);

        // è¢«æ‰«æåˆ°æ—¶é—ªçƒ
        const angleDiff = Math.abs(playerAngle - (angle % (Math.PI * 2)));
        if (angleDiff < 0.1) {
          ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x, y, 12, 0, Math.PI * 2);
          ctx.stroke();
        }
      });

      // æ·˜æ±°çš„ç©å®¶æ˜¾ç¤ºä¸ºç°è‰²
      players.forEach((player, index) => {
        if (!player.isAlive) {
          const playerAngle = (index / players.length) * Math.PI * 2;
          const x = centerX + Math.cos(playerAngle) * (radius - 10);
          const y = centerY + Math.sin(playerAngle) * (radius - 10);

          ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "rgba(255, 0, 0, 0.7)";
          ctx.font = "12px monospace";
          ctx.fillText("âœ—", x - 4, y + 4);
        }
      });

      angle += 0.02;
      animationId = requestAnimationFrame(draw);
    };

    draw();

    return () => cancelAnimationFrame(animationId);
  }, [players]);

  // å¤„ç†é¼ æ ‡æ‚¬åœ
  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!containerRef.current) return;
    const rect = containerRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = Math.min(centerX, centerY) - 20;

    // æ£€æŸ¥æ˜¯å¦æ‚¬åœåœ¨æŸä¸ªç©å®¶ä¸Š
    const found = players.find((player, index) => {
      if (!player.isAlive) return false;
      const playerAngle = (index / players.length) * Math.PI * 2;
      const distance = ((100 - player.humanityScore) / 100) * radius;
      const px = centerX + Math.cos(playerAngle) * distance;
      const py = centerY + Math.sin(playerAngle) * distance;
      const dx = x - (px / canvas.width) * rect.width;
      const dy = y - (py / canvas.height) * rect.height;
      return Math.sqrt(dx * dx + dy * dy) < 15;
    });

    setHoveredPlayer(found || null);
  };

  // ç©ºçŠ¶æ€å¤„ç†
  if (players.length === 0) {
    return (
      <div className="relative w-[300px] h-[300px] rounded-full border border-green-500/30 flex items-center justify-center">
        <div className="text-center">
          <div className="text-green-500 font-mono text-sm">NO PLAYERS</div>
          <div className="text-gray-500 font-mono text-xs mt-1">Waiting for participants...</div>
        </div>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      onMouseMove={handleMouseMove}
      onMouseLeave={() => setHoveredPlayer(null)}
      className="relative"
    >
      <canvas
        ref={canvasRef}
        width={300}
        height={300}
        className="rounded-full border border-green-500/30"
      />

      {/* æ‚¬åœæç¤º */}
      {hoveredPlayer && (
        <div className="absolute top-4 right-4 bg-black/90 border border-green-500/30 rounded-lg p-3 min-w-[150px]">
          <div className="text-green-400 font-mono text-xs mb-2">
            {hoveredPlayer.personaId}
          </div>
          <div className="grid grid-cols-2 gap-x-4 gap-y-1 text-xs">
            <span className="text-gray-400">HP:</span>
            <span className={`font-mono ${hoveredPlayer.humanityScore > 50 ? "text-green-400" : hoveredPlayer.humanityScore > 25 ? "text-yellow-400" : "text-red-400"}`}>
              {hoveredPlayer.humanityScore}
            </span>
            <span className="text-gray-400">Status:</span>
            <span className={hoveredPlayer.isVerifiedHuman ? "text-blue-400" : "text-gray-400"}>
              {hoveredPlayer.isVerifiedHuman ? "Verified Human" : "Unknown"}
            </span>
          </div>
        </div>
      )}

      <div className="absolute top-2 left-2 text-green-500 font-mono text-xs">
        ENTROPY RADAR
      </div>
    </div>
  );
}
```

### 8.8 é”™è¯¯è¾¹ç•Œ

```tsx
// packages/nextjs/app/arena/_components/ErrorBoundary.tsx

"use client";

import { Component, ReactNode } from "react";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        this.props.fallback || (
          <div className="min-h-screen bg-black flex items-center justify-center">
            <div className="bg-red-500/10 border border-red-500/30 rounded-lg p-8 text-center max-w-md">
              <div className="text-red-500 font-mono text-4xl mb-4">âš ï¸ SYSTEM ERROR</div>
              <div className="text-gray-400 font-mono text-sm mb-4">
                {this.state.error?.message || "Something went wrong"}
              </div>
              <button
                onClick={() => window.location.reload()}
                className="btn btn-outline btn-error btn-sm"
              >
                RELOAD SYSTEM
              </button>
            </div>
          </div>
        );
    }

    return this.props.children;
  }
}
```

### 8.9 åŠ è½½å±å¹•

```tsx
// packages/nextjs/app/arena/_components/LoadingScreen.tsx

"use client";

import { useEffect, useState } from "react";

export function LoadingScreen({ message = "INITIALIZING..." }: { message?: string }) {
  const [dots, setDots] = useState(".");

  useEffect(() => {
    const interval = setInterval(() => {
      setDots((prev) => (prev.length >= 3 ? "." : prev + "."));
    }, 500);

    return () => clearInterval(interval);
  }, []);

  return (
    <div className="min-h-screen bg-black flex items-center justify-center">
      <div className="text-center">
        <div className="inline-block mb-8">
          <div className="relative">
            <div className="w-16 h-16 border-4 border-green-500/30 rounded-full"></div>
            <div className="absolute top-0 left-0 w-16 h-16 border-4 border-transparent border-t-green-500 rounded-full animate-spin"></div>
          </div>
        </div>
        <div className="text-green-400 font-mono text-xl mb-2">
          {message}
        </div>
        <div className="text-green-500 font-mono text-sm">
          {dots}
        </div>

        {/* äºŒè¿›åˆ¶é›¨æ•ˆæœè£…é¥° */}
        <div className="fixed inset-0 pointer-events-none overflow-hidden -z-10">
          {Array.from({ length: 20 }).map((_, i) => (
            <div
              key={i}
              className="absolute text-green-500/10 font-mono text-xs animate-fall"
              style={{
                left: `${Math.random() * 100}%`,
                animationDuration: `${2 + Math.random() * 3}s`,
                animationDelay: `${Math.random() * 2}s`,
              }}
            >
              {Math.random() > 0.5 ? "1" : "0"}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}
```

### 8.10 Glitch æ·˜æ±°æ•ˆæœ

```tsx
// packages/nextjs/app/arena/_components/GlitchOverlay.tsx

"use client";

import { motion, AnimatePresence } from "framer-motion";
import { useEffect, useState } from "react";

// æ·»åŠ å…¨å±€ CSS åˆ° globals.css
/*
@keyframes glitch {
  0%, 100% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(-2px, -2px); }
  60% { transform: translate(2px, 2px); }
  80% { transform: translate(2px, -2px); }
}

.glitch-text {
  animation: glitch 0.3s infinite;
}

@keyframes scanline {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100vh); }
}
*/

export function GlitchOverlay({
  isActive,
  eliminatedPlayer,
  onDismiss,
}: {
  isActive: boolean;
  eliminatedPlayer: string;
  onDismiss?: () => void;
}) {
  const [showScanlines, setShowScanlines] = useState(true);

  useEffect(() => {
    if (isActive) {
      const timer = setTimeout(() => setShowScanlines(false), 3000);
      return () => clearTimeout(timer);
    }
  }, [isActive]);

  if (!isActive) return null;

  return (
    <AnimatePresence>
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        className="fixed inset-0 z-50 pointer-events-none"
        onClick={onDismiss}
      >
        {/* æ•…éšœæ¡çº¹ */}
        <div className="absolute inset-0 bg-red-500/10 animate-pulse" />

        {/* æ‰«æçº¿ */}
        {showScanlines && (
          <div
            className="absolute inset-0 opacity-20"
            style={{
              background: "repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,0,0.03) 2px, rgba(0,255,0,0.03) 4px)",
            }}
          />
        )}

        {/* æ·˜æ±°ä¿¡æ¯ */}
        <motion.div
          initial={{ scale: 0.5, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          className="absolute inset-0 flex items-center justify-center p-4"
        >
          <div className="bg-black/90 border-2 border-red-500 rounded-lg p-8 text-center max-w-md">
            <div className="text-red-500 font-mono text-4xl md:text-6xl mb-4 glitch-text">
              âš ï¸ ELIMINATED
            </div>
            <div className="text-green-400 font-mono text-sm md:text-lg mb-2 break-all">
              {eliminatedPlayer.slice(0, 10)}...{eliminatedPlayer.slice(-8)}
            </div>
            <div className="text-gray-500 font-mono text-sm">
              HUMANITY_SCORE: 0
            </div>
            <div className="text-red-400 font-mono text-xs mt-4 animate-pulse">
              CONNECTION TERMINATED
            </div>

            {onDismiss && (
              <button
                onClick={onDismiss}
                className="mt-4 btn btn-outline btn-error btn-sm"
              >
                DISMISS
              </button>
            )}
          </div>
        </motion.div>

        {/* CRT æ•ˆæœè¦†ç›– */}
        <div className="absolute inset-0 pointer-events-none bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjZmZmIiBmaWxsLW9wYWNpdHk9IjAuMSIvPgo8L3N2Zz4=')] opacity-5"></div>
      </motion.div>
    </AnimatePresence>
  );
}
```

### 8.11 ArenaTerminal ç»„ä»¶ (å­˜æ´»çŠ¶æ€æ£€æŸ¥ + ä¹è§‚æ›´æ–°)

```tsx
// packages/nextjs/app/arena/_components/ArenaTerminal.tsx

"use client";

import { useRef, useEffect, useState, useCallback } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useScaffoldWriteContract, useScaffoldEventHistory, useScaffoldReadContract } from "~~/hooks/scaffold-eth";
import { useAccount } from "wagmi";

type Message = {
  id: string;
  sender: string;
  content: string;
  timestamp: number;
};

type PendingMessage = {
  id: string;
  content: string;
  timestamp: number;
};

export function ArenaTerminal({ roomId }: { roomId: string }) {
  const { address } = useAccount();
  const inputRef = useRef<HTMLInputElement>(null);
  const terminalRef = useRef<HTMLDivElement>(null);

  // è·å–å½“å‰ç©å®¶çŠ¶æ€
  const { data: playerInfo } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "getPlayerInfo",
    args: [BigInt(roomId), address as `0x${string}`],
  });

  const isAlive = playerInfo?.[3] ?? true; // isAlive

  // è·å–æˆ¿é—´ä¿¡æ¯ä»¥ç¡®å®š startBlock
  const { data: roomInfo } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "getRoomInfo",
    args: [BigInt(roomId)],
  });

  // ç›‘å¬é“¾ä¸Š NewMessage äº‹ä»¶ (ä»æ¸¸æˆå¼€å§‹åŒºå—æŸ¥è¯¢ï¼Œé¿å…æ‰«æå…¨é“¾)
  const { data: messageEvents } = useScaffoldEventHistory({
    contractName: "TuringArena",
    eventName: "NewMessage",
    filters: { roomId: BigInt(roomId) },
    fromBlock: roomInfo?.startBlock ?? 0n,
    watch: true,
    blockData: true,
  });

  // æœ¬åœ°å¾…å‘é€æ¶ˆæ¯ (ä¹è§‚æ›´æ–°)
  const [pendingMessages, setPendingMessages] = useState<PendingMessage[]>([]);

  // è½¬æ¢äº‹ä»¶ä¸ºæ¶ˆæ¯æ ¼å¼
  const onchainMessages: Message[] = (messageEvents || []).map((event: any) => ({
    id: event.log.transactionHash,
    sender: event.args.sender as string,
    content: event.args.content as string,
    timestamp: Number(event.args.timestamp),
  }));

  // åˆå¹¶é“¾ä¸Šæ¶ˆæ¯å’Œå¾…å‘é€æ¶ˆæ¯
  const messages: Message[] = [
    ...onchainMessages,
    ...pendingMessages,
  ].sort((a, b) => a.timestamp - b.timestamp);

  // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [messages.length]);

  const { writeContractAsync, isPending } = useScaffoldWriteContract({
    contractName: "TuringArena",
  });

  const sendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isPending) return;
    if (!isAlive) {
      alert("You have been eliminated and cannot send messages!");
      return;
    }

    // æ¶ˆæ¯é•¿åº¦é™åˆ¶
    if (content.length > 280) {
      alert("Message too long (max 280 characters)");
      return;
    }

    // ä¹è§‚æ›´æ–°ï¼šç«‹å³æ˜¾ç¤ºæ¶ˆæ¯
    const tempMessage: PendingMessage = {
      id: `pending-${Date.now()}`,
      content,
      timestamp: Date.now() / 1000,
    };
    setPendingMessages((prev) => [...prev, tempMessage]);

    try {
      await writeContractAsync({
        functionName: "sendMessage",
        args: [BigInt(roomId), content],
      });

      // æˆåŠŸåç§»é™¤å¾…å‘é€æ¶ˆæ¯
      setPendingMessages((prev) => prev.filter((m) => m.id !== tempMessage.id));

      if (inputRef.current) {
        inputRef.current.value = "";
      }
    } catch (error) {
      // å¤±è´¥åç§»é™¤å¾…å‘é€æ¶ˆæ¯
      setPendingMessages((prev) => prev.filter((m) => m.id !== tempMessage.id));
      console.error("Failed to send message:", error);
      alert("Failed to send message. Please try again.");
    }
  }, [roomId, isAlive, isPending, writeContractAsync]);

  // è¢«æ·˜æ±°åçš„ç•Œé¢
  if (!isAlive && playerInfo) {
    return (
      <div className="bg-black border border-red-500/30 rounded-lg p-4 h-[600px] flex flex-col">
        <div className="flex items-center gap-2 mb-4 border-b border-red-500/20 pb-2">
          <div className="w-3 h-3 rounded-full bg-red-500" />
          <span className="text-red-500 font-mono text-sm">
            RTTA://room/{roomId}/terminal [TERMINATED]
          </span>
        </div>

        <div className="flex-1 flex items-center justify-center">
          <div className="text-center">
            <div className="text-red-500 font-mono text-4xl mb-4">YOU ARE ELIMINATED</div>
            <div className="text-gray-500 font-mono text-sm">
              Humanity Score: 0
            </div>
            <div className="text-gray-600 font-mono text-xs mt-2">
              Rank: #{playerInfo[5]?.toString() || "?"}
            </div>
          </div>
        </div>

        {/* åªè¯»æ¶ˆæ¯å†å² */}
        <div
          ref={terminalRef}
          className="flex-1 overflow-y-auto space-y-2 font-mono text-sm opacity-50"
        >
          <AnimatePresence>
            {messages.map((msg) => (
              <motion.div
                key={msg.id}
                className="flex gap-2"
              >
                <span className="text-gray-500">
                  [{new Date(msg.timestamp * 1000).toLocaleTimeString()}]
                </span>
                <span className="text-gray-600">
                  {msg.sender.slice(0, 6)}...{msg.sender.slice(-4)}:
                </span>
                <span className="text-gray-500">{msg.content}</span>
              </motion.div>
            ))}
          </AnimatePresence>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-black border border-green-500/30 rounded-lg p-4 h-[400px] md:h-[600px] flex flex-col">
      {/* æ ‡é¢˜æ  */}
      <div className="flex items-center gap-2 mb-4 border-b border-green-500/20 pb-2">
        <div className="w-3 h-3 rounded-full bg-red-500" />
        <div className="w-3 h-3 rounded-full bg-yellow-500" />
        <div className="w-3 h-3 rounded-full bg-green-500" />
        <span className="text-green-500 font-mono text-sm ml-4 hidden sm:inline">
          RTTA://room/{roomId}/terminal
        </span>
        <span className="text-green-500 font-mono text-sm ml-4 sm:hidden">
          RTTA terminal
        </span>
        <div className="ml-auto flex items-center gap-2">
          <span className="text-xs text-gray-500">{messages.length} msgs</span>
        </div>
      </div>

      {/* æ¶ˆæ¯åŒºåŸŸ */}
      <div
        ref={terminalRef}
        className="flex-1 overflow-y-auto space-y-2 font-mono text-sm"
      >
        <AnimatePresence initial={false}>
          {messages.map((msg) => (
            <motion.div
              key={msg.id}
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 20 }}
              transition={{ duration: 0.2 }}
              className="flex gap-2"
            >
              <span className="text-cyan-400 text-xs flex-shrink-0">
                [{new Date(msg.timestamp * 1000).toLocaleTimeString()}]
              </span>
              <span className="text-purple-400 text-xs flex-shrink-0">
                {msg.sender === address ? (
                  <span className="text-yellow-400">YOU:</span>
                ) : (
                  <>{msg.sender.slice(0, 6)}...{msg.sender.slice(-4)}:</>
                )}
              </span>
              <span className={msg.id.startsWith("pending-") ? "text-yellow-400" : "text-green-400"}>
                {msg.content}
              </span>
            </motion.div>
          ))}
        </AnimatePresence>
      </div>

      {/* è¾“å…¥åŒºåŸŸ */}
      <div className="mt-4 flex items-center gap-2 border-t border-green-500/20 pt-4">
        <span className="text-green-500 font-mono hidden sm:block">{">"}</span>
        <input
          ref={inputRef}
          type="text"
          disabled={isPending || !isAlive}
          onKeyDown={(e) => e.key === "Enter" && sendMessage(e.currentTarget.value)}
          placeholder={isAlive ? "Enter message (max 280 chars)..." : "Eliminated - Cannot send messages"}
          className="flex-1 bg-transparent border-none outline-none text-green-400 font-mono placeholder:text-green-700 disabled:text-gray-600 disabled:cursor-not-allowed"
        />
        <button
          onClick={() => inputRef.current && sendMessage(inputRef.current.value)}
          disabled={isPending || !isAlive}
          className="text-green-500 hover:text-green-300 font-mono disabled:text-gray-600 disabled:cursor-not-allowed"
        >
          {isPending ? "[SENDING...]" : "[SEND]"}
        </button>
      </div>
    </div>
  );
}
```

### 8.12 ä¸»é¡µé¢ç»“æ„ (å“åº”å¼å¸ƒå±€)

```tsx
// packages/nextjs/app/arena/page.tsx

"use client";

import { Suspense } from "react";
import { ErrorBoundary } from "./_components/ErrorBoundary";
import { ArenaTerminal } from "./_components/ArenaTerminal";
import { PlayerRadar } from "./_components/PlayerRadar";
import { VotePanel } from "./_components/VotePanel";
import { PhaseTimer } from "./_components/PhaseTimer";
import { SessionKeyManager } from "./_components/SessionKeyManager";
import { LoadingScreen } from "./_components/LoadingScreen";
import { GlitchOverlay } from "./_components/GlitchOverlay";
import { useScaffoldEventHistory } from "~~/hooks/scaffold-eth";
import { useSearchParams } from "next/navigation";

export default function ArenaPage() {
  const searchParams = useSearchParams();
  const roomId = searchParams.get("roomId") || "1";

  // ç›‘å¬æ·˜æ±°äº‹ä»¶
  const { data: eliminationEvents } = useScaffoldEventHistory({
    contractName: "TuringArena",
    eventName: "PlayerEliminated",
    filters: { roomId: BigInt(roomId) },
  });

  const latestElimination = eliminationEvents?.[0];
  const isEliminated = latestElimination?.args[1] === address; // éœ€è¦ä» account è·å–

  return (
    <ErrorBoundary>
      <Suspense fallback={<LoadingScreen />}>
        <main className="min-h-screen bg-black text-white p-2 md:p-4 lg:p-8">
          {/* æ·˜æ±°è¦†ç›–å±‚ */}
          <GlitchOverlay
            isActive={!!latestElimination}
            eliminatedPlayer={latestElimination?.args[1] || ""}
            onDismiss={() => window.location.reload()}
          />

          {/* é¡µé¢æ ‡é¢˜ */}
          <div className="mb-4 flex items-center justify-between">
            <h1 className="text-2xl md:text-4xl font-bold font-mono tracking-wider bg-gradient-to-r from-green-400 to-cyan-400 bg-clip-text text-transparent">
              REVERSE TURING TEST ARENA
            </h1>
            <SessionKeyManager roomId={roomId} />
          </div>

          {/* Phase å€’è®¡æ—¶ - ç§»åŠ¨ç«¯å…¨å®½ï¼Œæ¡Œé¢ç«¯å›ºå®šå®½åº¦ */}
          <div className="mb-4 max-w-4xl mx-auto">
            <PhaseTimer roomId={roomId} />
          </div>

          {/* ä¸»å†…å®¹åŒº - å“åº”å¼ç½‘æ ¼å¸ƒå±€ */}
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 max-w-7xl mx-auto">
            {/* å·¦ä¾§ï¼šç©å®¶é›·è¾¾ (æ¡Œé¢ç«¯) / é¡¶éƒ¨ (ç§»åŠ¨ç«¯) */}
            <div className="lg:col-span-1 order-2 lg:order-1">
              <div className="flex flex-col items-center gap-4">
                <PlayerRadar roomId={roomId} />
                <div className="w-full bg-gray-900/50 border border-gray-700 rounded-lg p-4 hidden lg:block">
                  <h3 className="text-gray-400 font-mono text-sm mb-2">PLAYER STATS</h3>
                  {/* ç©å®¶ç»Ÿè®¡ */}
                </div>
              </div>
            </div>

            {/* ä¸­é—´ï¼šèŠå¤©ç»ˆç«¯ */}
            <div className="lg:col-span-2 order-1 lg:order-2">
              <ArenaTerminal roomId={roomId} />

              {/* æŠ•ç¥¨é¢æ¿ - æ¡Œé¢ç«¯å¹¶æ’ï¼Œç§»åŠ¨ç«¯å †å  */}
              <div className="mt-4">
                <VotePanel roomId={roomId} currentAddress={address} />
              </div>
            </div>
          </div>

          {/* ç§»åŠ¨ç«¯åº•éƒ¨ï¼šç©å®¶åˆ—è¡¨ */}
          <div className="lg:hidden mt-4 bg-gray-900/50 border border-gray-700 rounded-lg p-4">
            <h3 className="text-gray-400 font-mono text-sm mb-2">PLAYERS ({/* ç©å®¶æ•°é‡ */})</h3>
            {/* ç§»åŠ¨ç«¯ç©å®¶åˆ—è¡¨ */}
          </div>
        </main>
      </Suspense>
    </ErrorBoundary>
  );
}
```

### 8.13 è§†è§‰æ•ˆæœå¢å¼ºç»„ä»¶

#### 8.13.1 ç²’å­ç³»ç»ŸèƒŒæ™¯

```tsx
// packages/nextjs/app/arena/_components/ParticleBackground.tsx

"use client";

import { useEffect, useRef } from "react";

export function ParticleBackground() {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    let particles: Array<{
      x: number;
      y: number;
      vx: number;
      vy: number;
      size: number;
      color: string;
      alpha: number;
    }> = [];

    // åˆå§‹åŒ–ç²’å­
    for (let i = 0; i < 100; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 2 + 1,
        color: ["#00ff00", "#00ffff", "#ff00ff"][Math.floor(Math.random() * 3)],
        alpha: Math.random() * 0.5 + 0.1,
      });
    }

    let animationId: number;

    const animate = () => {
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      particles.forEach((p) => {
        p.x += p.vx;
        p.y += p.vy;

        // è¾¹ç•Œåå¼¹
        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

        // ç»˜åˆ¶ç²’å­
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.alpha;
        ctx.fill();

        // è¿çº¿æ•ˆæœ
        particles.forEach((p2) => {
          const dx = p.x - p2.x;
          const dy = p.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 80) {
            ctx.beginPath();
            ctx.strokeStyle = p.color;
            ctx.globalAlpha = (1 - dist / 80) * 0.2;
            ctx.lineWidth = 0.5;
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        });
      });

      ctx.globalAlpha = 1;
      animationId = requestAnimationFrame(animate);
    };

    animationId = requestAnimationFrame(animate);

    return () => cancelAnimationFrame(animationId);
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className="fixed inset-0 pointer-events-none z-0"
      style={{ width: "100%", height: "100%" }}
    />
  );
}
```

#### 8.13.2 éœ“è™¹è¾¹æ¡†æ•ˆæœ

```tsx
// packages/nextjs/app/arena/_components/NeonBorder.tsx

"use client";

import { useEffect, useState } from "react";

type Props = {
  children: React.ReactNode;
  color?: "cyan" | "purple" | "green" | "red" | "orange";
  className?: string;
};

export function NeonBorder({ children, color = "cyan", className = "" }: Props) {
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });

  const colorMap = {
    cyan: "0, 255, 255",
    purple: "168, 85, 247",
    green: "0, 255, 100",
    red: "255, 0, 100",
    orange: "255, 165, 0",
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    const rect = e.currentTarget.getBoundingClientRect();
    setMousePos({
      x: ((e.clientX - rect.left) / rect.width) * 100,
      y: ((e.clientY - rect.top) / rect.height) * 100,
    });
  };

  return (
    <div
      onMouseMove={handleMouseMove}
      className={`relative group ${className}`}
    >
      {/* åŠ¨æ€å…‰æ™•è¾¹æ¡† */}
      <div
        className="absolute inset-0 rounded-lg opacity-50 blur-sm transition-opacity group-hover:opacity-100"
        style={{
          background: `radial-gradient(circle at ${mousePos.x}% ${mousePos.y}%, rgba(${colorMap[color]}, 0.4) 0%, transparent 70%)`,
        }}
      />

      {/* æ‰«æçº¿è¾¹æ¡† */}
      <div className="absolute inset-0 rounded-lg">
        <div
          className="absolute inset-0 rounded-lg"
          style={{
            background: `conic-gradient(from 0deg at ${mousePos.x}% ${mousePos.y}%, transparent 0deg, rgba(${colorMap[color]}, 0.3) ${mousePos.x * 3.6}deg, transparent 180deg)`,
            animation: "rotate 4s linear infinite",
          }}
        />
      </div>

      {/* å†…å®¹ */}
      <div className="relative z-10">{children}</div>
    </div>
  );
}
```

#### 8.13.3 èµ›åšæœ‹å…‹æ ‡é¢˜æ•ˆæœ

```tsx
// packages/nextjs/app/arena/_components/CyberTitle.tsx

"use client";

import { useEffect, useState } from "react";

export function CyberTitle({ text }: { text: string }) {
  const [scrambleText, setScrambleText] = useState(text);

  useEffect(() => {
    const chars = "!<>-_\\/[]{}â€”~+=*:,#$%@"; // èµ›åšæœ‹å…‹é£æ ¼å­—ç¬¦
    let iteration = 0;

    const interval = setInterval(() => {
      setScrambleText(
        text
          .split("")
          .map((char, index) => {
            if (index < iteration) {
              return text[index];
            }
            return chars[Math.floor(Math.random() * chars.length)];
          })
          .join("")
      );

      if (iteration >= text.length) {
        clearInterval(interval);
        setScrambleText(text);
      }
      iteration += 1;
    }, 50);

    return () => clearInterval(interval);
  }, [text]);

  return (
    <h1 className="font-mono font-bold text-transparent bg-clip-text">
      {scrambleText}
    </h1>
  );
}
```

#### 8.13.4 çŸ©é˜µé›¨æ•ˆæœ

```tsx
// packages/nextjs/app/arena/_components/MatrixRain.tsx

"use client";

import { useEffect, useRef } from "react";

export function MatrixRain({ opacity = 0.1 }: { opacity?: number }) {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const columns = Math.floor(canvas.width / 20);
    const drops: number[] = Array(columns).fill(1);

    const chars = "0123456789ABCDEF@#$%^&*";

    const draw = () => {
      ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#0F0";
      ctx.font = "15px monospace";

      for (let i = 0; i < drops.length; i++) {
        const text = chars[Math.floor(Math.random() * chars.length)];
        ctx.fillText(text, i * 20, drops[i] * 20);

        if (drops[i] * 20 > canvas.height && Math.random() > 0.975) {
          drops[i] = 0;
        }
        drops[i]++;
      }
    };

    const interval = setInterval(draw, 50);
    return () => clearInterval(interval);
  }, [opacity]);

  return (
    <canvas
      ref={canvasRef}
      className="fixed inset-0 pointer-events-none z-0"
      style={{ opacity }}
    />
  );
}
```

#### 8.13.5 è„‰å†²å‘å…‰å¡ç‰‡

```tsx
// packages/nextjs/app/arena/_components/PulseCard.tsx

"use client";

import { ReactNode } from "react";

type Props = {
  children: ReactNode;
  className?: string;
  glowColor?: "cyan" | "green" | "red" | "purple";
  intensity?: "low" | "medium" | "high";
};

export function PulseCard({ children, className = "", glowColor = "cyan", intensity = "medium" }: Props) {
  const glowClassMap = {
    cyan: "shadow-cyan-500/50 hover:shadow-cyan-500/100",
    green: "shadow-green-500/50 hover:shadow-green-500/100",
    red: "shadow-red-500/50 hover:shadow-red-500/100",
    purple: "shadow-purple-500/50 hover:shadow-purple-500/100",
  };

  return (
    <div
      className={`
        relative bg-black/80 backdrop-blur-sm border rounded-xl
        transition-all duration-300
        hover:scale-105
        ${glowClassMap[glowColor]}
        ${className}
      `}
    >
      {/* å†…éƒ¨å‘å…‰è¾¹æ¡† */}
      <div
        className={`absolute inset-0 rounded-xl border-2 opacity-0 transition-opacity group-hover:opacity-100`}
        style={{ borderColor: glowColor === "cyan" ? "#0ff" : glowColor === "green" ? "#0f0" : glowColor === "red" ? "#f00" : "#a0f" }}
      />

      {/* è§’è½è£…é¥° */}
      <div className="absolute top-0 left-0 w-4 h-4 border-l-2 border-t-2 border-cyan-400" />
      <div className="absolute top-0 right-0 w-4 h-4 border-r-2 border-t-2 border-cyan-400" />
      <div className="absolute bottom-0 left-0 w-4 h-4 border-l-2 border-b-2 border-cyan-400" />
      <div className="absolute bottom-0 right-0 w-4 h-4 border-r-2 border-b-2 border-cyan-400" />

      {children}
    </div>
  );
}
```

#### 8.13.6 æ•°å­—ç¿»é¡µè®¡æ•°å™¨

```tsx
// packages/nextjs/app/arena/_components/FlipNumber.tsx

"use client";

import { useEffect, useState } from "react";

type Props = {
  value: number;
  size?: "sm" | "md" | "lg";
};

export function FlipNumber({ value, size = "md" }: Props) {
  const [displayValue, setDisplayValue] = useState(value);
  const [isFlipping, setIsFlipping] = useState(false);

  const sizeMap = {
    sm: "w-8 h-12 text-lg",
    md: "w-12 h-16 text-2xl",
    lg: "w-16 h-20 text-3xl",
  };

  useEffect(() => {
    if (value !== displayValue) {
      setIsFlipping(true);
      setTimeout(() => {
        setDisplayValue(value);
        setIsFlipping(false);
      }, 150);
    }
  }, [value, displayValue]);

  const padValue = displayValue.toString().padStart(2, "0");

  return (
    <div className={`${sizeMap[size]} relative bg-black border border-green-500/50 rounded flex items-center justify-center overflow-hidden`}>
      {/* èƒŒæ™¯æ•°å­— */}
      <div className={`absolute inset-0 flex items-center justify-center font-mono text-green-900`}>
        {padValue}
      </div>

      {/* å‰æ™¯æ•°å­—ï¼ˆå¸¦åŠ¨ç”»ï¼‰ */}
      <div
        className={`
          relative z-10 font-mono font-bold text-green-400
          transition-transform duration-150
          ${isFlipping ? "-translate-y-full" : "translate-y-0"}
        `}
      >
        {padValue}
      </div>

      {/* å‘å…‰æ•ˆæœ */}
      <div className="absolute inset-0 bg-green-500/20 blur-sm" />
    </div>
  );
}
```

#### 8.13.7 éœ“è™¹åŠ è½½è¿›åº¦æ¡

```tsx
// packages/nextjs/app/arena/_components/CyberProgressBar.tsx

"use client";

import { useEffect, useState } from "react";

type Props = {
  progress: number; // 0-100
  label?: string;
  color?: "cyan" | "green" | "red" | "purple" | "rainbow";
};

export function CyberProgressBar({ progress, label, color = "cyan" }: Props) {
  const [displayProgress, setDisplayProgress] = useState(0);

  useEffect(() => {
    setDisplayProgress(progress);
  }, [progress]);

  const colorGradients = {
    cyan: "from-cyan-400 to-blue-500",
    green: "from-green-400 to-emerald-500",
    red: "from-red-400 to-rose-500",
    purple: "from-purple-400 to-pink-500",
    rainbow: "from-red-500 via-yellow-500 via-green-500 via-blue-500 to-purple-500",
  };

  return (
    <div className="w-full">
      {label && (
        <div className="flex justify-between mb-2 font-mono text-xs">
          <span className="text-gray-400">{label}</span>
          <span className={`font-bold ${displayProgress >= 80 ? "text-green-400" : displayProgress >= 50 ? "text-yellow-400" : "text-red-400"}`}>
            {Math.round(displayProgress)}%
          </span>
        </div>
      )}

      <div className="relative h-3 bg-gray-900 rounded-full overflow-hidden border border-gray-700">
        {/* è¿›åº¦æ¡èƒŒæ™¯åŠ¨ç”» */}
        <div
          className={`absolute inset-0 bg-gradient-to-r ${colorGradients[color]} opacity-20 blur-sm`}
        />

        {/* å®é™…è¿›åº¦æ¡ */}
        <div
          className={`h-full bg-gradient-to-r ${colorGradients[color]} transition-all duration-300 ease-out relative`}
          style={{ width: `${displayProgress}%` }}
        >
          {/* å‘å…‰å‰æ²¿ */}
          <div
            className="absolute right-0 top-0 h-full w-2 bg-white/50 blur-sm"
          style={{ boxShadow: "0 0 10px rgba(255,255,255,0.8)" }}
          />
        </div>

        {/* ç½‘æ ¼è¦†ç›– */}
        <div className="absolute inset-0" style={{
          backgroundImage: `
            linear-gradient(90deg, transparent 1px, transparent 1px),
            linear-gradient(transparent 1px, transparent 1px)
          `,
          backgroundSize: "10px 10px",
          opacity: 0.1,
        }} />
      </div>
    </div>
  );
}
```

#### 8.13.8 æ‰“å­—æœºæ–‡æœ¬æ•ˆæœ

```tsx
// packages/nextjs/app/arena/_components/TypewriterText.tsx

"use client";

import { useEffect, useState } from "react";

type Props = {
  text: string;
  delay?: number;
  speed?: number;
  className?: string;
  cursor?: boolean;
};

export function TypewriterText({ text, delay = 0, speed = 50, className = "", cursor = true }: Props) {
  const [displayText, setDisplayText] = useState("");
  const [isComplete, setIsComplete] = useState(false);

  useEffect(() => {
    const timeout = setTimeout(() => {
      let index = 0;
      const interval = setInterval(() => {
        setDisplayText(text.slice(0, index + 1));
        index++;

        if (index === text.length) {
          clearInterval(interval);
          setIsComplete(true);
        }
      }, speed);

      return () => clearInterval(interval);
    }, delay);

    return () => clearTimeout(timeout);
  }, [text, delay, speed]);

  return (
    <span className={className}>
      {displayText}
      {cursor && (
        <span className={`
          inline-block w-2 h-4 bg-green-400 ml-1 animate-pulse
          ${isComplete ? "opacity-0" : "opacity-100"}
        `} />
      )}
    </span>
  );
}
```

#### 8.13.9 3D æ‚¬åœå¡ç‰‡æ•ˆæœ

```tsx
// packages/nextjs/app/arena/_components/HolographicCard.tsx

"use client";

import { useRef, useState } from "react";

type Props = {
  children: React.ReactNode;
  className?: string;
};

export function HolographicCard({ children, className = "" }: Props) {
  const cardRef = useRef<HTMLDivElement>(null);
  const [rotateX, setRotateX] = useState(0);
  const [rotateY, setRotateY] = useState(0);

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!cardRef.current) return;

    const rect = cardRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const centerX = rect.width / 2;
    const centerY = rect.height / 2;

    // è®¡ç®—æ—‹è½¬è§’åº¦ (æœ€å¤§ 15 åº¦)
    const rotateX = ((y - centerY) / centerY) * -15;
    const rotateY = ((x - centerX) / centerX) * 15;

    setRotateX(rotateX);
    setRotateY(rotateY);
  };

  const handleMouseLeave = () => {
    setRotateX(0);
    setRotateY(0);
  };

  return (
    <div
      ref={cardRef}
      onMouseMove={handleMouseMove}
      onMouseLeave={handleMouseLeave}
      className={className}
      style={{
        perspective: "1000px",
        transformStyle: "preserve-3d",
      }}
    >
      <div
        className="relative w-full h-full transition-transform duration-100 ease-out"
        style={{
          transform: `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`,
          transformStyle: "preserve-3d",
        }}
      >
        {/* å…¨æ¯å…‰æ³½å±‚ */}
        <div
          className="absolute inset-0 rounded-lg opacity-0 pointer-events-none transition-opacity duration-300"
          style={{
            background: `linear-gradient(135deg, rgba(255,255,255,0.4) 0%, transparent 50%, rgba(0,255,255,0.4) 100%)`,
            transform: "translateZ(20px)",
          }}
        />

        {/* æ‰«æçº¿æ•ˆæœ */}
        <div
          className="absolute inset-0 rounded-lg overflow-hidden pointer-events-none"
        >
          <div
            className="w-full h-full animate-scanline"
            style={{
              background: "linear-gradient(180deg, transparent 40%, rgba(0,255,255,0.1) 50%, transparent 60%)",
            }}
          />
        </div>

        {/* å†…å®¹ */}
        <div style={{ transform: "translateZ(10px)" }}>
          {children}
        </div>
      </div>
    </div>
  );
}
```

#### 8.13.10 æ•…éšœæ–‡å­—æ•ˆæœ

```tsx
// packages/nextjs/app/arena/_components/GlitchText.tsx

"use client";

import { ReactNode } from "react";

type Props = {
  children: ReactNode;
  trigger?: "hover" | "always" | "never";
  intensity?: "low" | "medium" | "high";
};

export function GlitchText({ children, trigger = "hover", intensity = "medium" }: Props) {
  const intensityMap = {
    low: "0.02s 0.06s 0.12s infinite",
    medium: "0.02s 0.04s 0.08s infinite",
    high: "0.01s 0.02s 0.04s infinite",
  };

  return (
    <span className={`inline-block ${trigger === "hover" ? "hover:glitch" : "glitch"}`} style={{
      animation: trigger === "never" ? "none" : intensityMap[intensity],
    }}>
      {/* ä¸»æ–‡å­— */}
      <span className="relative z-10">{children}</span>

      {/* æ•…éšœå±‚ */}
      <span className="absolute left-0 top-0 z-0 text-red-500" style={{ clipPath: "polygon(0 0, 100% 0, 100% 20%, 0 20%, 0 100%, 0 0)" }}>
        {children}
      </span>
      <span className="absolute left-0 top-0 z-0 text-cyan-500" style={{ clipPath: "polygon(0 0, 0 0, 100% 0, 100% 20%, 0 20%, 0 100%, 0 0)" }}>
        {children}
      </span>
    </span>
  );
}
```

#### 8.13.11 å…¨å±€ CSS åŠ¨ç”»å®šä¹‰ (æ·»åŠ åˆ° globals.css)

```css
/* packages/nextjs/app/globals.css */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* ============ èµ›åšæœ‹å…‹ä¸»é¢˜åŠ¨ç”» ============ */

/* éœ“è™¹æ–‡å­—å‘å…‰ */
@keyframes rainbow-glow {
  0%, 100% {
    text-shadow:
      0 0 5px #fff,
      0 0 10px #fff,
      0 0 20px #ff00ff,
      0 0 40px #ff00ff,
      0 0 80px #ff00ff;
  }
  50% {
    text-shadow:
      0 0 5px #fff,
      0 0 10px #fff,
      0 0 20px #00ffff,
      0 0 40px #00ffff,
      0 0 80px #00ffff;
  }
}

.rainbow-glow {
  animation: rainbow-glow 3s ease-in-out infinite;
}

/* è¾¹æ¡†æµå…‰ */
@keyframes border-flow {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

.border-flow {
  background: linear-gradient(90deg, #0ff, #0f0, #ff0, #f0f, #0ff);
  background-size: 400% 400%;
  animation: border-flow 8s linear infinite;
}

/* è„‰å†²ç¯ */
@keyframes pulse-ring {
  0% {
    transform: scale(0.8);
    opacity: 1;
  }
  100% {
    transform: scale(2);
    opacity: 0;
  }
}

.pulse-ring::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 50%;
  border: 2px solid currentColor;
  animation: pulse-ring 2s ease-out infinite;
}

/* æ•…éšœé—ªå± */
@keyframes glitch-flash {
  0%, 90%, 92%, 94%, 96%, 100% {
    opacity: 1;
  }
  91%, 93%, 95%, 97% {
    opacity: 0.8;
    background: rgba(255, 0, 100, 0.1);
  }
}

/* æ•°å­—æ»šåŠ¨ */
@keyframes number-scroll {
  0% { transform: translateY(0); }
  100% { transform: translateY(-100%); }
}

/* éœ“è™¹è¾¹æ¡† */
@keyframes rainbow-border {
  0% { border-color: #ff0000; box-shadow: 0 0 5px #ff0000; }
  14% { border-color: #ff8800; box-shadow: 0 0 5px #ff8800; }
  28% { border-color: #ffff00; box-shadow: 0 0 5px #ffff00; }
  42% { border-color: #88ff00; box-shadow: 0 0 5px #88ff00; }
  57% { border-color: #00ff00; box-shadow: 0 0 5px #00ff00; }
  71% { border-color: #00ff88; box-shadow: 0 0 5px #00ff88; }
  85% { border-color: #0088ff; box-shadow: 0 0 5px #0088ff; }
  100% { border-color: #0000ff; box-shadow: 0 0 5px #0000ff; }
}

.rainbow-border {
  animation: rainbow-border 3s linear infinite;
}

/* æ–‡å­—è§£ç åŠ¨ç”» */
@keyframes decode {
  0% { opacity: 0; }
  50% { opacity: 0.5; }
  100% { opacity: 1; }
}

.decode-text::after {
  content: attr(data-text);
  animation: decode 0.5s ease-out;
}

/* ä¿¡å·å¹²æ‰°æ•ˆæœ */
@keyframes signal-noise {
  0%, 100% { background-position: 0% 0%; }
  10% { background-position: -5% -10%; }
  20% { background-position: 10% 5%; }
  30% { background-position: -3% 10%; }
  40% { background-position: 5% -5%; }
  50% { background-position: 0% 0%; }
  60% { background-position: -2% -8%; }
  70% { background-position: 7% 3%; }
  80% { background-position: -4% 6%; }
  90% { background-position: 3% -4%; }
}

.signal-noise {
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3C/svg%3E");
  animation: signal-noise 0.5s steps(10) infinite;
}

/* é—ªçƒæ–‡å­— */
@keyframes flicker {
  0%, 18%, 22%, 25%, 53%, 57%, 100% {
    opacity: 1;
    text-shadow: 0 0 4px currentColor;
  }
  20%, 24%, 55% {
    opacity: 0.4;
    text-shadow: none;
  }
}

.flicker {
  animation: flicker 3s infinite;
}

/* æ—‹è½¬ (NeonBorder è¾¹æ¡†æ‰«æ) */
@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* äºŒè¿›åˆ¶é›¨ä¸‹è½ (LoadingScreen) */
@keyframes fall {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100vh); }
}

.animate-fall {
  animation: fall linear infinite;
}

/* æ‰«æçº¿ (HolographicCard) */
@keyframes scanline {
  0% { transform: translateY(-100%); }
  100% { transform: translateY(100%); }
}

.animate-scanline {
  animation: scanline 3s linear infinite;
}

/* æ•…éšœæ•ˆæœ (GlitchText) */
@keyframes glitch {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(-2px, -2px); }
  60% { transform: translate(2px, 2px); }
  80% { transform: translate(2px, -2px); }
  100% { transform: translate(0); }
}

.glitch:hover::before,
.glitch:hover::after {
  content: attr(data-text);
}
```

### 8.14 å®Œæ•´çš„ä¸»é¡µé¢å®ç° (æ•´åˆæ‰€æœ‰ç‰¹æ•ˆ)

```tsx
// packages/nextjs/app/arena/page.tsx

"use client";

import { Suspense, useState, useCallback } from "react";
import { useSearchParams } from "next/navigation";
import { useAccount } from "wagmi";

// Zustand Store
import { useGameStore } from "~~/services/store/gameStore";

// ç»„ä»¶
import { ErrorBoundary } from "./_components/ErrorBoundary";
import { ArenaTerminal } from "./_components/ArenaTerminal";
import { PlayerRadar } from "./_components/PlayerRadar";
import { VotePanel } from "./_components/VotePanel";
import { PhaseTimer } from "./_components/PhaseTimer";
import { SessionKeyManager } from "./_components/SessionKeyManager";
import { LoadingScreen } from "./_components/LoadingScreen";
import { GlitchOverlay } from "./_components/GlitchOverlay";
import { ParticleBackground } from "./_components/ParticleBackground";
import { MatrixRain } from "./_components/MatrixRain";
import { CyberTitle } from "./_components/CyberTitle";
import { NeonBorder } from "./_components/NeonBorder";
import { PulseCard } from "./_components/PulseCard";
import { FlipNumber } from "./_components/FlipNumber";
import { HolographicCard } from "./_components/HolographicCard";
import { GlitchText } from "./_components/GlitchText";

// æ–°å¢ç»„ä»¶
import { GameHUD } from "./_components/GameHUD";
import { KillFeed } from "./_components/KillFeed";
import { GameCountdown } from "./_components/GameCountdown";
import { PhaseTransition } from "./_components/PhaseTransition";
import { VictoryScreen } from "./_components/VictoryScreen";
import { DataStream } from "./_components/DataStream";
import { VotingGraph } from "./_components/VotingGraph";

export default function ArenaPage() {
  const searchParams = useSearchParams();
  const roomId = searchParams.get("roomId") || "1";
  const { address } = useAccount();
  const [showMatrix, setShowMatrix] = useState(true);

  // ä» gameStore è¯»å– UI çŠ¶æ€
  const uiFlags = useGameStore((s) => s.uiFlags);
  const gamePhase = useGameStore((s) => s.gamePhase);
  const setUIFlag = useGameStore((s) => s.setUIFlag);

  const handleCountdownComplete = useCallback(() => {
    setUIFlag("showCountdown", false);
  }, [setUIFlag]);

  const handlePhaseTransitionComplete = useCallback(() => {
    setUIFlag("showPhaseTransition", false);
  }, [setUIFlag]);

  const handleVictoryDismiss = useCallback(() => {
    setUIFlag("showVictory", false);
  }, [setUIFlag]);

  return (
    <ErrorBoundary>
      <Suspense fallback={<LoadingScreen message="INITIALIZING NEURAL LINK..." />}>
        {/* ===== å…¨å±è¦†ç›–å±‚ ===== */}

        {/* å¼€å±€å€’è®¡æ—¶ (8.21) */}
        {uiFlags.showCountdown && (
          <GameCountdown onComplete={handleCountdownComplete} />
        )}

        {/* Phase åˆ‡æ¢è¿‡æ¸¡ (8.22) */}
        {uiFlags.showPhaseTransition && gamePhase !== "WAITING" && gamePhase !== "ENDED" && (
          <PhaseTransition
            phase={gamePhase as "PHASE_1" | "PHASE_2" | "PHASE_3"}
            onComplete={handlePhaseTransitionComplete}
          />
        )}

        {/* èƒœåˆ©ç»“ç®— (8.23) */}
        {uiFlags.showVictory && (
          <VictoryScreen
            roomId={roomId}
            champion=""   // ç”±å®é™…åˆçº¦æ•°æ®å¡«å……
            rewardAmount={0n}
            onDismiss={handleVictoryDismiss}
          />
        )}

        {/* èƒŒæ™¯ç‰¹æ•ˆå±‚ */}
        <div className="fixed inset-0 pointer-events-none z-0">
          <ParticleBackground />
          {showMatrix && <MatrixRain opacity={0.05} />}
        </div>

        {/* å®æ—¶æ·˜æ±°é€šçŸ¥ (8.24) */}
        {uiFlags.showKillFeed && <KillFeed roomId={roomId} />}

        {/* é¡¶éƒ¨ HUD (8.25) */}
        <GameHUD roomId={roomId} />

        <main className="min-h-screen bg-black text-white p-2 md:p-4 lg:p-8 relative z-10">
          {/* æ·˜æ±°è¦†ç›–å±‚ */}
          <GlitchOverlay
            isActive={false} // ç”±å®é™…æ·˜æ±°çŠ¶æ€æ§åˆ¶
            eliminatedPlayer={""}
          />

          {/* é¡µé¢æ ‡é¢˜ - èµ›åšæœ‹å…‹é£æ ¼ */}
          <div className="mb-6 flex items-center justify-between border-b border-cyan-500/30 pb-4">
            <div className="flex items-center gap-4">
              <div className="w-12 h-12 border-2 border-cyan-400 flex items-center justify-center">
                <span className="text-2xl">â—ˆ</span>
              </div>
              <div>
                <CyberTitle text="REVERSE TURING TEST" />
                <div className="text-cyan-400 font-mono text-xs tracking-widest rainbow-glow">
                  ARENA PROTOCOL v2.066
                </div>
              </div>
            </div>
            <div className="flex items-center gap-2">
              <FlipNumber value={Number(roomId)} />
              <SessionKeyManager roomId={roomId} />
            </div>
          </div>

          {/* Phase å€’è®¡æ—¶ - éœ“è™¹è¾¹æ¡† */}
          <NeonBorder color="purple" className="mb-4">
            <PhaseTimer roomId={roomId} />
          </NeonBorder>

          {/* ä¸»å†…å®¹åŒº - å…¨æ¯å¡ç‰‡é£æ ¼ */}
          <div className="grid grid-cols-1 lg:grid-cols-4 gap-4 max-w-7xl mx-auto">
            {/* å·¦ä¾§ï¼šç©å®¶é›·è¾¾ + æŠ•ç¥¨å…³ç³»å›¾ (8.27) */}
            <div className="lg:col-span-1 order-2 lg:order-1 space-y-4">
              <HolographicCard>
                <PulseCard glowColor="green" intensity="low">
                  <div className="p-4">
                    <h3 className="text-green-400 font-mono text-sm mb-4 flex items-center gap-2">
                      <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse" />
                      ENTROPY RADAR
                    </h3>
                    <PlayerRadar roomId={roomId} />
                  </div>
                </PulseCard>
              </HolographicCard>

              {/* æŠ•ç¥¨ç½‘ç»œå›¾ */}
              <HolographicCard>
                <div className="p-4">
                  <h3 className="text-purple-400 font-mono text-sm mb-2 flex items-center gap-2">
                    <span className="w-2 h-2 rounded-full bg-purple-500 animate-pulse" />
                    VOTE NETWORK
                  </h3>
                  <VotingGraph />
                </div>
              </HolographicCard>
            </div>

            {/* ä¸­é—´ï¼šèŠå¤©ç»ˆç«¯ + æŠ•ç¥¨é¢æ¿ */}
            <div className="lg:col-span-2 order-1 lg:order-2">
              <NeonBorder color="cyan">
                <ArenaTerminal roomId={roomId} />
              </NeonBorder>

              {/* æŠ•ç¥¨é¢æ¿ */}
              <div className="mt-4">
                <HolographicCard>
                  <PulseCard glowColor="red" intensity="medium">
                    <div className="p-4">
                      <h3 className="text-red-400 font-mono text-sm mb-4 flex items-center gap-2">
                        <span className="w-2 h-2 rounded-full bg-red-500 animate-pulse" />
                        VOTE TERMINAL
                      </h3>
                      <VotePanel roomId={roomId} currentAddress={address || "0x0"} />
                    </div>
                  </PulseCard>
                </HolographicCard>
              </div>
            </div>

            {/* å³ä¾§ï¼šé“¾ä¸Šæ•°æ®æµ (8.28) */}
            <div className="lg:col-span-1 order-3">
              <DataStream roomId={roomId} />
            </div>
          </div>

          {/* åº•éƒ¨çŠ¶æ€æ  - æµå…‰è¾¹æ¡† */}
          <div className="mt-6 border-flow border-2 rounded-lg p-4">
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center font-mono text-xs">
              <div>
                <div className="text-gray-500">NODES</div>
                <div className="text-green-400 flicker">ONLINE</div>
              </div>
              <div>
                <div className="text-gray-500">LATENCY</div>
                <div className="text-cyan-400">
                  <FlipNumber value={12} />ms
                </div>
              </div>
              <div>
                <div className="text-gray-500">BLOCK</div>
                <div className="text-purple-400">#12,456,789</div>
              </div>
              <div>
                <div className="text-gray-500">STATUS</div>
                <div className="text-green-400 flex items-center justify-center gap-1">
                  <span className="w-2 h-2 rounded-full bg-green-500 animate-ping" />
                  ACTIVE
                </div>
              </div>
            </div>
          </div>
        </main>

        {/* è§†è§‰ç‰¹æ•ˆåˆ‡æ¢æŒ‰é’® */}
        <button
          onClick={() => setShowMatrix(!showMatrix)}
          className="fixed bottom-4 right-4 z-50 btn btn-sm btn-ghost btn-outline"
        >
          {showMatrix ? "HIDE" : "SHOW"} MATRIX
        </button>
      </Suspense>
    </ErrorBoundary>
  );
}
```

### 8.15 éŸ³æ•ˆæç¤ºç³»ç»Ÿ

```tsx
// packages/nextjs/app/arena/_components/SoundIndicator.tsx

"use client";

import { createContext, useContext, useState, ReactNode } from "react";

type SoundEffect = "message" | "vote" | "eliminate" | "phase" | "join";

interface SoundContextType {
  playSound: (effect: SoundEffect) => void;
  isMuted: boolean;
  toggleMute: () => void;
}

const SoundContext = createContext<SoundContextType | null>(null);

export function useSound() {
  const context = useContext(SoundContext);
  if (!context) {
    return { playSound: () => {}, isMuted: true, toggleMute: () => {} };
  }
  return context;
}

export function SoundProvider({ children }: { children: ReactNode }) {
  const [isMuted, setIsMuted] = useState(true);

  const playSound = (effect: SoundEffect) => {
    if (isMuted) return;

    const sounds = {
      message: "/sounds/message.mp3",
      vote: "/sounds/vote.mp3",
      eliminate: "/sounds/eliminate.mp3",
      phase: "/sounds/phase.mp3",
      join: "/sounds/join.mp3",
    };

    const audio = new Audio(sounds[effect]);
    audio.volume = 0.3;
    audio.play().catch(console.error);
  };

  return (
    <SoundContext.Provider value={{ playSound, isMuted, toggleMute: () => setIsMuted(!isMuted) }}>
      {children}
    </SoundContext.Provider>
  );
}

// éŸ³æ•ˆæŒ‡ç¤ºå™¨ç»„ä»¶
export function SoundToggle() {
  const { isMuted, toggleMute } = useSound();

  return (
    <button
      onClick={toggleMute}
      className="fixed top-4 right-4 z-50 btn btn-circle btn-sm btn-ghost"
      title={isMuted ? "Enable Sound" : "Mute Sound"}
    >
      {isMuted ? "ğŸ”‡" : "ğŸ”Š"}
    </button>
  );
}
```

### 8.16 è§†è§‰æ•ˆæœä½¿ç”¨ç¤ºä¾‹

```tsx
// åœ¨é¡µé¢ä¸­ä½¿ç”¨å„ç§ç‰¹æ•ˆ

// 1. èµ›åšæœ‹å…‹æ ‡é¢˜ + éœ“è™¹å‘å…‰
<CyberTitle text="WELCOME TO THE ARENA" />
<span className="rainbow-glow">SURVIVE IF YOU CAN</span>

// 2. éœ“è™¹è¾¹æ¡†åŒ…è£¹å†…å®¹
<NeonBorder color="purple">
  <div className="p-6">Your content here</div>
</NeonBorder>

// 3. æ•…éšœæ–‡å­—æ•ˆæœ
<GlitchText intensity="high">
  <span className="text-4xl font-bold">ELIMINATED</span>
</GlitchText>

// 4. è„‰å†²å‘å…‰å¡ç‰‡
<PulseCard glowColor="cyan" intensity="high">
  <div className="p-8">
    <h2>URGENT: Phase 2 Starting</h2>
  </div>
</PulseCard>

// 5. æ•°å­—ç¿»é¡µå€’è®¡æ—¶
<FlipNumber value={30} />

// 6. èµ›åšé£æ ¼è¿›åº¦æ¡
<CyberProgressBar progress={75} label="ELIMINATION PROGRESS" color="red" />

// 7. å…¨æ¯å¡ç‰‡åŒ…è£¹
<HolographicCard>
  <div className="p-8">
    Your content with 3D perspective effect
  </div>
</HolographicCard>

// 8. æ‰“å­—æœºæ–‡æœ¬
<TypewriterText
  text="Searching for human presence..."
  speed={30}
  cursor={true}
/>
```

---

### 8.17 å“åº”å¼è®¾è®¡è§„èŒƒ

| ç»„ä»¶ | ç§»åŠ¨ç«¯ (< 768px) | å¹³æ¿ (768px - 1024px) | æ¡Œé¢ç«¯ (> 1024px) |
|------|------------------|----------------------|----------------------|
| å¸ƒå±€ | å•åˆ—å †å  | ä¸¤åˆ— (1:2) | ä¸‰åˆ— (1:2: å³ä¾§è¾¹æ ) |
| ArenaTerminal é«˜åº¦ | 400px | 500px | 600px |
| PlayerRadar | éšè— | æ˜¾ç¤º | æ˜¾ç¤º + æ‚¬åœä¿¡æ¯ |
| PhaseTimer | å…¨å®½ | æœ€å¤§å®½åº¦ 4xl | æœ€å¤§å®½åº¦ 4xl |
| ç©å®¶åˆ—è¡¨ | åº•éƒ¨æŠ˜å  | å³ä¾§ | å³ä¾§è¾¹æ  |
| æŠ•ç¥¨é¢æ¿ | åº•éƒ¨ | å¹¶æ’ | å¹¶æ’ |

### 8.18 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

| ä¼˜åŒ–ç‚¹ | å®ç°æ–¹å¼ |
|--------|----------|
| **äº‹ä»¶æŸ¥è¯¢ä¼˜åŒ–** | ä½¿ç”¨ `roomInfo.startBlock` ä½œä¸º `fromBlock` |
| **ç»„ä»¶æ‡’åŠ è½½** | ä½¿ç”¨ `React.lazy` åŠ¨æ€å¯¼å…¥é‡å‹ç»„ä»¶ |
| **å›¾ç‰‡ä¼˜åŒ–** | ä½¿ç”¨ Next.js Image ç»„ä»¶ + WebP æ ¼å¼ |
| **Canvas åŠ¨ç”»** | ä½¿ç”¨ `requestAnimationFrame` + èŠ‚æµ |
| **çŠ¶æ€ç®¡ç†** | ä½¿ç”¨ Zustand + React Query çš„ç¼“å­˜æœºåˆ¶ |
| **ä¹è§‚æ›´æ–°** | æ¶ˆæ¯å‘é€ç«‹å³æ˜¾ç¤º UIï¼Œå¤±è´¥æ—¶å›æ»š |
| **é”™è¯¯é‡è¯•** | ä½¿ç”¨ React Query çš„ `retry` é…ç½® |

### 8.19 Game State Store (`gameStore.ts`)

ä½¿ç”¨ Zustand æ„å»ºå…¨å±€æ¸¸æˆçŠ¶æ€ç®¡ç†ï¼Œé©±åŠ¨æ‰€æœ‰ arena å†…çš„ UI ç»„ä»¶ã€‚

**æ–‡ä»¶**: `packages/nextjs/services/store/gameStore.ts`

```typescript
// packages/nextjs/services/store/gameStore.ts

import { create } from "zustand";

// ============ ç±»å‹å®šä¹‰ ============

type GamePhase = "WAITING" | "PHASE_1" | "PHASE_2" | "PHASE_3" | "ENDED";

type MessageType = "chat" | "system" | "vote" | "elimination" | "phase";

type ChatMessage = {
  id: string;
  sender: string;        // åœ°å€æˆ– "SYSTEM"
  content: string;
  type: MessageType;
  timestamp: number;
  txHash?: string;
};

type PlayerInfo = {
  address: string;
  personaId: string;
  humanityScore: number;
  isAlive: boolean;
  joinBlock: number;
  eliminationRank?: number;
  votesCast: number;
  votesReceived: number;
};

type Elimination = {
  player: string;
  eliminatedBy: string;
  reason: string;
  block: number;
  timestamp: number;
};

type UIFlags = {
  showCountdown: boolean;
  showPhaseTransition: boolean;
  showVictory: boolean;
  showKillFeed: boolean;
  showVotingGraph: boolean;
};

type GameState = {
  // æˆ¿é—´ä¿¡æ¯
  currentRoom: string | null;
  roomTier: "Bronze" | "Silver" | "Gold" | null;
  entryFee: bigint;

  // æ¸¸æˆçŠ¶æ€
  gamePhase: GamePhase;
  previousPhase: GamePhase | null;
  phaseStartBlock: number;
  roundNumber: number;

  // ç©å®¶
  players: PlayerInfo[];
  myPlayer: PlayerInfo | null;
  aliveCount: number;

  // èŠå¤©
  chatMessages: ChatMessage[];

  // æŠ•ç¥¨ä¸æ·˜æ±°
  pendingVotes: Record<string, string>;  // voter -> target
  eliminations: Elimination[];

  // UI æ§åˆ¶
  uiFlags: UIFlags;

  // ============ Actions ============

  setRoom: (roomId: string, tier: "Bronze" | "Silver" | "Gold", entryFee: bigint) => void;
  addMessage: (message: ChatMessage) => void;
  addMessages: (messages: ChatMessage[]) => void;
  setPlayers: (players: PlayerInfo[]) => void;
  setMyPlayer: (player: PlayerInfo) => void;
  eliminatePlayer: (elimination: Elimination) => void;
  transitionPhase: (newPhase: GamePhase, startBlock: number) => void;
  setVictory: () => void;
  registerVote: (voter: string, target: string) => void;
  clearVotes: () => void;
  setUIFlag: (flag: keyof UIFlags, value: boolean) => void;
  reset: () => void;
};

// ============ åˆå§‹çŠ¶æ€ ============

const initialState = {
  currentRoom: null,
  roomTier: null,
  entryFee: 0n,
  gamePhase: "WAITING" as GamePhase,
  previousPhase: null as GamePhase | null,
  phaseStartBlock: 0,
  roundNumber: 0,
  players: [],
  myPlayer: null,
  aliveCount: 0,
  chatMessages: [],
  pendingVotes: {},
  eliminations: [],
  uiFlags: {
    showCountdown: false,
    showPhaseTransition: false,
    showVictory: false,
    showKillFeed: true,
    showVotingGraph: false,
  },
};

// ============ Store ============

export const useGameStore = create<GameState>((set, get) => ({
  ...initialState,

  setRoom: (roomId, tier, entryFee) =>
    set({ currentRoom: roomId, roomTier: tier, entryFee }),

  addMessage: (message) =>
    set((state) => ({
      chatMessages: [...state.chatMessages.slice(-199), message], // ä¿ç•™æœ€è¿‘ 200 æ¡
    })),

  addMessages: (messages) =>
    set((state) => ({
      chatMessages: [...state.chatMessages, ...messages].slice(-200),
    })),

  setPlayers: (players) =>
    set({
      players,
      aliveCount: players.filter((p) => p.isAlive).length,
    }),

  setMyPlayer: (player) => set({ myPlayer: player }),

  eliminatePlayer: (elimination) =>
    set((state) => {
      const updatedPlayers = state.players.map((p) =>
        p.address === elimination.player ? { ...p, isAlive: false } : p,
      );
      return {
        players: updatedPlayers,
        aliveCount: updatedPlayers.filter((p) => p.isAlive).length,
        eliminations: [...state.eliminations, elimination],
        uiFlags: { ...state.uiFlags, showKillFeed: true },
      };
    }),

  transitionPhase: (newPhase, startBlock) =>
    set((state) => ({
      previousPhase: state.gamePhase,
      gamePhase: newPhase,
      phaseStartBlock: startBlock,
      roundNumber: state.roundNumber + 1,
      uiFlags: { ...state.uiFlags, showPhaseTransition: true },
    })),

  setVictory: () =>
    set((state) => ({
      gamePhase: "ENDED",
      uiFlags: { ...state.uiFlags, showVictory: true },
    })),

  registerVote: (voter, target) =>
    set((state) => ({
      pendingVotes: { ...state.pendingVotes, [voter]: target },
    })),

  clearVotes: () => set({ pendingVotes: {} }),

  setUIFlag: (flag, value) =>
    set((state) => ({
      uiFlags: { ...state.uiFlags, [flag]: value },
    })),

  reset: () => set(initialState),
}));
```

**å…³é”®è®¾è®¡å†³ç­–**:

| å†³ç­– | åŸå›  |
|------|------|
| æ¶ˆæ¯ä¸Šé™ 200 æ¡ | é˜²æ­¢è¶…é•¿æ¸¸æˆå†…å­˜æ³„æ¼ |
| `previousPhase` å­—æ®µ | Phase Transition åŠ¨ç”»éœ€è¦çŸ¥é“ from â†’ to |
| `uiFlags` ç‹¬ç«‹å¯¹è±¡ | é¿å… UI åŠ¨ç”»ä¸æ¸¸æˆé€»è¾‘è€¦åˆ |
| `pendingVotes` ä½¿ç”¨ Record | æ¯ä¸ª voter åªæœ‰ä¸€ä¸ª pending vote |

### 8.20 Lobby é¡µé¢ (`LobbyPage`)

æ›¿æ¢é»˜è®¤ SE-2 é¦–é¡µä¸º RTTA å¤§å…é¡µé¢ã€‚ç©å®¶åœ¨æ­¤æµè§ˆã€ç­›é€‰å¹¶åŠ å…¥ç«æŠ€åœºæˆ¿é—´ã€‚

#### 8.20.1 HeroSection

**æ–‡ä»¶**: `packages/nextjs/app/_components/HeroSection.tsx`

```tsx
// packages/nextjs/app/_components/HeroSection.tsx

"use client";

import { useEffect, useRef } from "react";
import { motion } from "framer-motion";
import { useScaffoldReadContract } from "~~/hooks/scaffold-eth";

export const HeroSection = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  // è¯»å–å…¨å±€ç»Ÿè®¡
  const { data: totalRooms } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "roomCount",
  });

  const { data: totalRewards } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "totalRewardsDistributed",
  });

  // ç½‘æ ¼ç²’å­èƒŒæ™¯
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = 400;

    const particles: { x: number; y: number; vx: number; vy: number }[] = [];
    for (let i = 0; i < 50; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
      });
    }

    let animationId: number;
    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "rgba(0, 255, 255, 0.1)";

      particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;

        // ç»˜åˆ¶è¿çº¿
        particles.slice(i + 1).forEach((q) => {
          const dist = Math.hypot(p.x - q.x, p.y - q.y);
          if (dist < 150) {
            ctx.globalAlpha = 1 - dist / 150;
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(q.x, q.y);
            ctx.stroke();
          }
        });

        // ç»˜åˆ¶èŠ‚ç‚¹
        ctx.fillStyle = "rgba(0, 255, 255, 0.6)";
        ctx.globalAlpha = 1;
        ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
      });

      animationId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationId);
  }, []);

  return (
    <section className="relative overflow-hidden py-16 md:py-24">
      <canvas ref={canvasRef} className="absolute inset-0 pointer-events-none" />

      <div className="relative z-10 text-center">
        {/* Glitch æ ‡é¢˜ */}
        <motion.h1
          className="text-4xl md:text-6xl lg:text-8xl font-bold font-mono tracking-tighter glitch-text"
          initial={{ opacity: 0, y: 30 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8, ease: "easeOut" }}
        >
          <span className="text-cyan-400">REVERSE</span>{" "}
          <span className="text-white">TURING TEST</span>
          <br />
          <span className="text-purple-400 neon-pulse">ARENA</span>
        </motion.h1>

        <motion.p
          className="mt-4 text-gray-400 font-mono text-sm md:text-base tracking-widest"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.5 }}
        >
          &gt; PROVE YOUR HUMANITY. SURVIVE THE MACHINES.
        </motion.p>

        {/* ç»Ÿè®¡æ  */}
        <motion.div
          className="mt-8 flex justify-center gap-8 md:gap-16"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.8 }}
        >
          <div className="text-center">
            <div className="text-2xl md:text-3xl font-mono text-cyan-400">
              {totalRooms?.toString() || "0"}
            </div>
            <div className="text-xs text-gray-500 font-mono uppercase tracking-wider">
              Total Rooms
            </div>
          </div>
          <div className="text-center">
            <div className="text-2xl md:text-3xl font-mono text-green-400">
              --
            </div>
            <div className="text-xs text-gray-500 font-mono uppercase tracking-wider">
              Active Players
            </div>
          </div>
          <div className="text-center">
            <div className="text-2xl md:text-3xl font-mono text-purple-400">
              {totalRewards ? `${(Number(totalRewards) / 1e18).toFixed(1)}` : "0"} MON
            </div>
            <div className="text-xs text-gray-500 font-mono uppercase tracking-wider">
              Rewards Paid
            </div>
          </div>
        </motion.div>
      </div>
    </section>
  );
};
```

#### 8.20.2 RoomCard

**æ–‡ä»¶**: `packages/nextjs/app/_components/RoomCard.tsx`

```tsx
// packages/nextjs/app/_components/RoomCard.tsx

"use client";

import { useRouter } from "next/navigation";
import { formatEther } from "viem";
import { useScaffoldReadContract } from "~~/hooks/scaffold-eth";

type RoomTier = "Bronze" | "Silver" | "Gold";

const TIER_STYLES: Record<RoomTier, { border: string; badge: string; glow: string }> = {
  Bronze: {
    border: "border-orange-600/50",
    badge: "bg-orange-600 text-white",
    glow: "shadow-orange-600/20",
  },
  Silver: {
    border: "border-gray-400/50",
    badge: "bg-gray-400 text-black",
    glow: "shadow-gray-400/20",
  },
  Gold: {
    border: "border-yellow-400/50",
    badge: "bg-yellow-400 text-black",
    glow: "shadow-yellow-400/20",
  },
};

const TIER_MAP: Record<number, RoomTier> = { 0: "Bronze", 1: "Silver", 2: "Gold" };

export const RoomCard = ({ roomId }: { roomId: number }) => {
  const router = useRouter();

  const { data: roomInfo } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "getRoomInfo",
    args: [BigInt(roomId)],
  });

  if (!roomInfo) return null;

  const tier = TIER_MAP[Number(roomInfo.tier)] || "Bronze";
  const styles = TIER_STYLES[tier];
  const playerCount = Number(roomInfo.playerCount);
  const maxPlayers = Number(roomInfo.maxPlayers);
  const entryFee = roomInfo.entryFee;
  const isWaiting = !roomInfo.isActive;
  const aliveCount = Number(roomInfo.aliveCount);

  const phaseLabel = !roomInfo.isActive
    ? "WAITING"
    : roomInfo.isEnded
      ? "COMPLETED"
      : `PHASE ${roomInfo.currentPhase}`;

  return (
    <div
      className={`
        relative p-4 border ${styles.border} rounded-lg bg-black/80
        hover:shadow-lg ${styles.glow} transition-all duration-300
        cursor-pointer group room-glow
      `}
      onClick={() => router.push(`/arena?roomId=${roomId}`)}
    >
      {/* Tier å¾½ç«  */}
      <div className="flex items-center justify-between mb-3">
        <span className={`px-2 py-0.5 text-xs font-mono rounded ${styles.badge}`}>
          {tier.toUpperCase()}
        </span>
        <span className="text-xs font-mono text-gray-500">
          #{roomId}
        </span>
      </div>

      {/* ç©å®¶æ•° */}
      <div className="mb-3">
        <div className="flex justify-between items-baseline">
          <span className="text-gray-400 font-mono text-xs">PLAYERS</span>
          <span className="text-white font-mono">
            {isWaiting ? `${playerCount}/${maxPlayers}` : `${aliveCount}/${playerCount} alive`}
          </span>
        </div>
        <div className="mt-1 h-1 bg-gray-800 rounded-full overflow-hidden">
          <div
            className="h-full bg-cyan-400 transition-all duration-500"
            style={{ width: `${(playerCount / maxPlayers) * 100}%` }}
          />
        </div>
      </div>

      {/* Entry fee */}
      <div className="flex justify-between items-center mb-3">
        <span className="text-gray-400 font-mono text-xs">ENTRY</span>
        <span className="text-green-400 font-mono text-sm">
          {formatEther(entryFee)} MON
        </span>
      </div>

      {/* Phase çŠ¶æ€ */}
      <div className="flex justify-between items-center">
        <span className="text-gray-400 font-mono text-xs">STATUS</span>
        <span
          className={`font-mono text-xs px-2 py-0.5 rounded ${
            isWaiting
              ? "text-cyan-400 bg-cyan-400/10"
              : roomInfo.isEnded
                ? "text-gray-500 bg-gray-500/10"
                : "text-red-400 bg-red-400/10 animate-pulse"
          }`}
        >
          {phaseLabel}
        </span>
      </div>

      {/* Hover æç¤º */}
      {isWaiting && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity rounded-lg">
          <span className="text-cyan-400 font-mono text-sm tracking-wider">
            [ JOIN ARENA ]
          </span>
        </div>
      )}
    </div>
  );
};
```

#### 8.20.3 CreateRoomModal

**æ–‡ä»¶**: `packages/nextjs/app/_components/CreateRoomModal.tsx`

```tsx
// packages/nextjs/app/_components/CreateRoomModal.tsx

"use client";

import { useState } from "react";
import { parseEther } from "viem";
import { useScaffoldWriteContract } from "~~/hooks/scaffold-eth";

type TierOption = {
  id: number;
  name: string;
  label: string;
  players: string;
  fee: string;
  feeWei: bigint;
  color: string;
};

const TIERS: TierOption[] = [
  {
    id: 0,
    name: "Quick",
    label: "BRONZE",
    players: "5-10",
    fee: "0.01",
    feeWei: parseEther("0.01"),
    color: "text-orange-400 border-orange-400",
  },
  {
    id: 1,
    name: "Standard",
    label: "SILVER",
    players: "10-20",
    fee: "0.05",
    feeWei: parseEther("0.05"),
    color: "text-gray-300 border-gray-300",
  },
  {
    id: 2,
    name: "Epic",
    label: "GOLD",
    players: "20-50",
    fee: "0.1",
    feeWei: parseEther("0.1"),
    color: "text-yellow-400 border-yellow-400",
  },
];

export const CreateRoomModal = ({
  isOpen,
  onClose,
}: {
  isOpen: boolean;
  onClose: () => void;
}) => {
  const [selectedTier, setSelectedTier] = useState<TierOption>(TIERS[0]);
  const [maxPlayers, setMaxPlayers] = useState(10);

  const { writeContractAsync, isPending } = useScaffoldWriteContract({
    contractName: "TuringArena",
  });

  const handleCreate = async () => {
    try {
      await writeContractAsync({
        functionName: "createRoom",
        args: [selectedTier.id, maxPlayers],
      });
      onClose();
    } catch (err) {
      console.error("Failed to create room:", err);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
      <div className="w-full max-w-md border border-cyan-500/30 bg-black/95 rounded-lg p-6 cyber-border">
        <div className="flex justify-between items-center mb-6">
          <h2 className="text-cyan-400 font-mono text-lg tracking-wider">
            CREATE ARENA
          </h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-white font-mono"
          >
            [X]
          </button>
        </div>

        {/* Tier é€‰æ‹© */}
        <div className="mb-6">
          <label className="text-gray-400 font-mono text-xs block mb-2">
            SELECT TIER
          </label>
          <div className="grid grid-cols-3 gap-2">
            {TIERS.map((tier) => (
              <button
                key={tier.id}
                onClick={() => setSelectedTier(tier)}
                className={`
                  p-3 border rounded text-center font-mono text-xs transition-all
                  ${
                    selectedTier.id === tier.id
                      ? `${tier.color} bg-white/5`
                      : "border-gray-700 text-gray-500 hover:border-gray-500"
                  }
                `}
              >
                <div className="text-sm font-bold">{tier.label}</div>
                <div className="text-[10px] mt-1">{tier.players} players</div>
                <div className="text-[10px]">{tier.fee} MON</div>
              </button>
            ))}
          </div>
        </div>

        {/* Player limit slider */}
        <div className="mb-6">
          <label className="text-gray-400 font-mono text-xs block mb-2">
            MAX PLAYERS: <span className="text-cyan-400">{maxPlayers}</span>
          </label>
          <input
            type="range"
            min={5}
            max={50}
            value={maxPlayers}
            onChange={(e) => setMaxPlayers(Number(e.target.value))}
            className="range range-xs range-primary w-full"
          />
        </div>

        {/* Entry fee æ˜¾ç¤º */}
        <div className="mb-6 p-3 bg-gray-900/50 rounded border border-gray-800">
          <div className="flex justify-between font-mono text-xs">
            <span className="text-gray-400">ENTRY FEE</span>
            <span className="text-green-400">{selectedTier.fee} MON</span>
          </div>
          <div className="flex justify-between font-mono text-xs mt-1">
            <span className="text-gray-400">MAX PRIZE POOL</span>
            <span className="text-purple-400">
              {(parseFloat(selectedTier.fee) * maxPlayers).toFixed(2)} MON
            </span>
          </div>
        </div>

        {/* åˆ›å»ºæŒ‰é’® */}
        <button
          onClick={handleCreate}
          disabled={isPending}
          className="btn btn-primary w-full font-mono tracking-wider"
        >
          {isPending ? "DEPLOYING ARENA..." : "INITIALIZE ARENA"}
        </button>
      </div>
    </div>
  );
};
```

#### 8.20.4 Lobby ä¸»é¡µé¢

**æ–‡ä»¶**: `packages/nextjs/app/page.tsx`

```tsx
// packages/nextjs/app/page.tsx

"use client";

import { useState } from "react";
import type { NextPage } from "next";
import { useScaffoldReadContract } from "~~/hooks/scaffold-eth";
import { HeroSection } from "./_components/HeroSection";
import { RoomCard } from "./_components/RoomCard";
import { CreateRoomModal } from "./_components/CreateRoomModal";

type FilterTab = "all" | "waiting" | "active" | "completed";

const Home: NextPage = () => {
  const [filter, setFilter] = useState<FilterTab>("all");
  const [showCreateModal, setShowCreateModal] = useState(false);

  const { data: roomCount } = useScaffoldReadContract({
    contractName: "TuringArena",
    functionName: "roomCount",
  });

  const totalRooms = Number(roomCount || 0);
  const roomIds = Array.from({ length: totalRooms }, (_, i) => i + 1);

  const FILTER_TABS: { key: FilterTab; label: string }[] = [
    { key: "all", label: "ALL" },
    { key: "waiting", label: "WAITING" },
    { key: "active", label: "IN PROGRESS" },
    { key: "completed", label: "COMPLETED" },
  ];

  return (
    <div className="min-h-screen bg-black text-white">
      <HeroSection />

      {/* æ§åˆ¶æ  */}
      <div className="max-w-7xl mx-auto px-4 md:px-8">
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
          {/* Filter tabs */}
          <div className="flex gap-1 bg-gray-900/50 p-1 rounded-lg">
            {FILTER_TABS.map((tab) => (
              <button
                key={tab.key}
                onClick={() => setFilter(tab.key)}
                className={`
                  px-4 py-1.5 font-mono text-xs rounded transition-all
                  ${
                    filter === tab.key
                      ? "bg-cyan-500/20 text-cyan-400"
                      : "text-gray-500 hover:text-gray-300"
                  }
                `}
              >
                {tab.label}
              </button>
            ))}
          </div>

          {/* Create room æŒ‰é’® */}
          <button
            onClick={() => setShowCreateModal(true)}
            className="btn btn-primary btn-sm font-mono tracking-wider"
          >
            + CREATE ARENA
          </button>
        </div>

        {/* Room åˆ—è¡¨ */}
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 pb-16">
          {roomIds.length === 0 ? (
            <div className="col-span-full text-center py-16">
              <div className="text-gray-600 font-mono text-sm">
                &gt; NO ACTIVE ARENAS DETECTED
              </div>
              <div className="text-gray-700 font-mono text-xs mt-2">
                Create the first arena to begin.
              </div>
            </div>
          ) : (
            roomIds.map((id) => <RoomCard key={id} roomId={id} />)
          )}
        </div>
      </div>

      <CreateRoomModal
        isOpen={showCreateModal}
        onClose={() => setShowCreateModal(false)}
      />
    </div>
  );
};

export default Home;
```

> **è¯´æ˜**: Filter åŠŸèƒ½çš„å®é™…ç­›é€‰é€»è¾‘éœ€è¦åœ¨ `RoomCard` ç»„ä»¶å†…éƒ¨æ ¹æ®åˆçº¦è¿”å›çš„æˆ¿é—´çŠ¶æ€è¿›è¡Œåˆ¤æ–­ï¼Œæˆ–åœ¨çˆ¶ç»„ä»¶ä¸­æ‰¹é‡æŸ¥è¯¢åè¿‡æ»¤ã€‚æ­¤å¤„ä¸ºç®€åŒ–èµ·è§ï¼Œç›´æ¥æ¸²æŸ“æ‰€æœ‰æˆ¿é—´å¡ç‰‡ã€‚

### 8.21 Game Countdown (`GameCountdown`)

å…¨å±å€’è®¡æ—¶è¦†ç›–å±‚ï¼Œåœ¨æ¸¸æˆå¼€å§‹æˆ–æ–° Phase è¿›å…¥æ—¶æ’­æ”¾ 3-2-1-FIGHT åŠ¨ç”»ã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/GameCountdown.tsx`

```tsx
// packages/nextjs/app/arena/_components/GameCountdown.tsx

"use client";

import { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";

const SEQUENCE = ["3", "2", "1", "FIGHT"];

export const GameCountdown = ({ onComplete }: { onComplete: () => void }) => {
  const [current, setCurrent] = useState(0);
  const [isVisible, setIsVisible] = useState(true);

  useEffect(() => {
    if (current >= SEQUENCE.length) {
      // æœ€åä¸€å¸§åœç•™ 600ms åæ¶ˆå¤±
      const timeout = setTimeout(() => {
        setIsVisible(false);
        onComplete();
      }, 600);
      return () => clearTimeout(timeout);
    }

    const timeout = setTimeout(() => {
      setCurrent((prev) => prev + 1);
    }, 800);

    return () => clearTimeout(timeout);
  }, [current, onComplete]);

  if (!isVisible) return null;

  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/90 backdrop-blur-sm">
      <AnimatePresence mode="wait">
        {current < SEQUENCE.length && (
          <motion.div
            key={SEQUENCE[current]}
            className={`
              font-mono font-black text-center
              ${current === 3 ? "text-red-500 text-8xl md:text-[12rem]" : "text-cyan-400 text-9xl md:text-[16rem]"}
            `}
            initial={{ scale: 3, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.5, opacity: 0 }}
            transition={{
              type: "spring",
              stiffness: 300,
              damping: 20,
              duration: 0.4,
            }}
          >
            {SEQUENCE[current]}

            {/* å†²å‡»æ³¢çº¹ */}
            <motion.div
              className="absolute inset-0 rounded-full border-2 border-cyan-400/30"
              initial={{ scale: 0.8, opacity: 1 }}
              animate={{ scale: 3, opacity: 0 }}
              transition={{ duration: 0.8, ease: "easeOut" }}
            />
          </motion.div>
        )}
      </AnimatePresence>

      {/* åº•éƒ¨æ‰«æçº¿ */}
      <div className="absolute bottom-0 left-0 right-0 h-1 scanline-horizontal" />
    </div>
  );
};
```

**åŠ¨ç”»åˆ†è§£**:

| é˜¶æ®µ | åŠ¨ç”»æ•ˆæœ | æ—¶é•¿ |
|------|----------|------|
| æ•°å­—è¿›å…¥ | `scale: 3 â†’ 1`ï¼Œå¼¹ç°§åŠ¨ç”» | 400ms |
| å†²å‡»æ³¢ | `scale: 0.8 â†’ 3`ï¼Œ`opacity: 1 â†’ 0` | 800ms |
| æ•°å­—é€€å‡º | `scale: 1 â†’ 0.5`ï¼Œæ¸éš | 300ms |
| "FIGHT" | çº¢è‰²é«˜äº® + æ›´å°å­—å· + åœç•™ 600ms | 600ms |

### 8.22 Phase Transition (`PhaseTransition`)

Phase åˆ‡æ¢æ—¶çš„å…¨å±ç”µå½±åŒ–è¿‡æ¸¡æ•ˆæœï¼Œé…åˆè‰²å½©å’Œæ‰«æçº¿å˜åŒ–ã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/PhaseTransition.tsx`

```tsx
// packages/nextjs/app/arena/_components/PhaseTransition.tsx

"use client";

import { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";

type Phase = "PHASE_1" | "PHASE_2" | "PHASE_3";

const PHASE_CONFIG: Record<Phase, { label: string; subtitle: string; color: string; bg: string }> = {
  PHASE_1: {
    label: "PHASE I",
    subtitle: "OBSERVATION",
    color: "text-green-400",
    bg: "from-green-900/30 to-transparent",
  },
  PHASE_2: {
    label: "PHASE II",
    subtitle: "SUSPICION",
    color: "text-yellow-400",
    bg: "from-yellow-900/30 to-transparent",
  },
  PHASE_3: {
    label: "PHASE III",
    subtitle: "ELIMINATION",
    color: "text-red-400",
    bg: "from-red-900/30 to-transparent",
  },
};

export const PhaseTransition = ({
  phase,
  onComplete,
}: {
  phase: Phase;
  onComplete: () => void;
}) => {
  const [isVisible, setIsVisible] = useState(true);
  const config = PHASE_CONFIG[phase];

  useEffect(() => {
    const timeout = setTimeout(() => {
      setIsVisible(false);
      onComplete();
    }, 2500);
    return () => clearTimeout(timeout);
  }, [onComplete]);

  if (!isVisible) return null;

  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 z-[90] flex items-center justify-center overflow-hidden"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.3 }}
      >
        {/* èƒŒæ™¯æ¸å˜ */}
        <div className={`absolute inset-0 bg-gradient-to-b ${config.bg}`} />

        {/* æ°´å¹³æ‰«æçº¿ wipe */}
        <motion.div
          className="absolute left-0 right-0 h-[2px] bg-white/80"
          initial={{ top: "-2px" }}
          animate={{ top: "100%" }}
          transition={{ duration: 1.5, ease: "easeInOut" }}
        />

        {/* Phase åç§° */}
        <div className="relative text-center">
          <motion.div
            className={`text-6xl md:text-8xl font-mono font-black ${config.color} tracking-widest`}
            initial={{ x: -100, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            transition={{ type: "spring", stiffness: 200, damping: 15, delay: 0.3 }}
          >
            {config.label}
          </motion.div>

          <motion.div
            className="text-xl md:text-2xl font-mono text-gray-400 tracking-[0.5em] mt-2"
            initial={{ x: 100, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            transition={{ type: "spring", stiffness: 200, damping: 15, delay: 0.6 }}
          >
            {config.subtitle}
          </motion.div>
        </div>

        {/* é¡¶éƒ¨+åº•éƒ¨æ‰«æçº¿ */}
        <div className="absolute top-0 left-0 right-0 h-16 scanline opacity-50" />
        <div className="absolute bottom-0 left-0 right-0 h-16 scanline opacity-50" />
      </motion.div>
    </AnimatePresence>
  );
};
```

**Phase é¢œè‰²ç¼–ç **:

| Phase | é¢œè‰² | è¯­ä¹‰ |
|-------|------|------|
| Phase 1 | ğŸŸ¢ Green | è§‚å¯ŸæœŸï¼Œå®‰å…¨ |
| Phase 2 | ğŸŸ¡ Yellow | æ€€ç–‘æœŸï¼Œç´§å¼ å‡çº§ |
| Phase 3 | ğŸ”´ Red | æ·˜æ±°æœŸï¼Œå±é™© |

### 8.23 Victory Screen (`VictoryScreen`)

æ¸¸æˆç»“æŸåçš„å† å†›å±•ç¤ºä¸å¥–åŠ±é¢†å–ç•Œé¢ã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/VictoryScreen.tsx`

```tsx
// packages/nextjs/app/arena/_components/VictoryScreen.tsx

"use client";

import { useEffect, useRef, useCallback } from "react";
import { motion } from "framer-motion";
import { formatEther } from "viem";
import { useScaffoldWriteContract } from "~~/hooks/scaffold-eth";
import { Address } from "~~/components/scaffold-eth";
import { useGameStore } from "~~/services/store/gameStore";

export const VictoryScreen = ({
  roomId,
  champion,
  rewardAmount,
  onDismiss,
}: {
  roomId: string;
  champion: string;
  rewardAmount: bigint;
  onDismiss: () => void;
}) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const myPlayer = useGameStore((s) => s.myPlayer);
  const isChampion = myPlayer?.address.toLowerCase() === champion.toLowerCase();

  const { writeContractAsync, isPending } = useScaffoldWriteContract({
    contractName: "TuringArena",
  });

  // é‡‘è‰²ç²’å­åº†ç¥æ•ˆæœ
  const initParticles = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particles: {
      x: number;
      y: number;
      vx: number;
      vy: number;
      size: number;
      alpha: number;
      color: string;
    }[] = [];

    const COLORS = ["#FFD700", "#FFA500", "#FFEC8B", "#DAA520", "#F0E68C"];

    for (let i = 0; i < 150; i++) {
      particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height - canvas.height,
        vx: (Math.random() - 0.5) * 3,
        vy: Math.random() * 2 + 1,
        size: Math.random() * 4 + 1,
        alpha: Math.random() * 0.8 + 0.2,
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
      });
    }

    let animationId: number;
    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      particles.forEach((p) => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.02; // é‡åŠ›
        if (p.y > canvas.height) {
          p.y = -10;
          p.vy = Math.random() * 2 + 1;
        }

        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
      });
      ctx.globalAlpha = 1;
      animationId = requestAnimationFrame(animate);
    };
    animate();

    return () => cancelAnimationFrame(animationId);
  }, []);

  useEffect(() => {
    const cleanup = initParticles();
    return cleanup;
  }, [initParticles]);

  const handleClaim = async () => {
    try {
      await writeContractAsync({
        functionName: "claimReward",
        args: [BigInt(roomId)],
      });
    } catch (err) {
      console.error("Claim failed:", err);
    }
  };

  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/95">
      <canvas ref={canvasRef} className="absolute inset-0 pointer-events-none" />

      <motion.div
        className="relative z-10 text-center max-w-lg mx-auto px-4"
        initial={{ scale: 0, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ type: "spring", stiffness: 200, damping: 15, delay: 0.5 }}
      >
        {/* çš‡å†  */}
        <motion.div
          className="text-7xl md:text-9xl mb-4 crown-float"
          animate={{ y: [0, -15, 0] }}
          transition={{ repeat: Infinity, duration: 2, ease: "easeInOut" }}
        >
          ğŸ‘‘
        </motion.div>

        <div className="text-yellow-400 font-mono text-lg tracking-[0.3em] mb-2">
          {isChampion ? "YOU ARE THE" : "THE CHAMPION IS"}
        </div>

        <div className="text-4xl md:text-6xl font-mono font-black text-white mb-4 neon-text">
          CHAMPION
        </div>

        {/* å† å†›åœ°å€ */}
        <div className="mb-6">
          <Address address={champion} />
        </div>

        {/* ç»Ÿè®¡ */}
        <div className="grid grid-cols-2 gap-4 mb-8 max-w-sm mx-auto">
          <div className="bg-gray-900/50 border border-gray-800 rounded p-3">
            <div className="text-gray-500 font-mono text-xs">REWARD</div>
            <div className="text-green-400 font-mono text-lg">
              {formatEther(rewardAmount)} MON
            </div>
          </div>
          <div className="bg-gray-900/50 border border-gray-800 rounded p-3">
            <div className="text-gray-500 font-mono text-xs">HUMANITY</div>
            <div className="text-cyan-400 font-mono text-lg">
              {myPlayer?.humanityScore ?? "--"}
            </div>
          </div>
        </div>

        {/* é¢†å–æŒ‰é’® (ä»…å† å†›å¯è§) */}
        {isChampion && (
          <motion.button
            onClick={handleClaim}
            disabled={isPending}
            className="btn btn-lg font-mono tracking-widest bg-yellow-500 text-black hover:bg-yellow-400 border-none"
            whileHover={{ scale: 1.05 }}
            whileTap={{ scale: 0.95 }}
          >
            {isPending ? "CLAIMING..." : "CLAIM REWARD"}
          </motion.button>
        )}

        {/* å…³é—­ */}
        <button
          onClick={onDismiss}
          className="mt-4 block mx-auto text-gray-500 hover:text-gray-300 font-mono text-xs"
        >
          [ BACK TO LOBBY ]
        </button>
      </motion.div>
    </div>
  );
};
```

### 8.24 Kill Feed (`KillFeed`)

å®æ—¶æ·˜æ±°ä¿¡æ¯ä¾§è¾¹æ ï¼Œç›‘å¬ `PlayerEliminated` äº‹ä»¶å¹¶ä»¥æ»‘å…¥åŠ¨ç”»é€æ¡æ˜¾ç¤ºã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/KillFeed.tsx`

```tsx
// packages/nextjs/app/arena/_components/KillFeed.tsx

"use client";

import { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useScaffoldEventHistory } from "~~/hooks/scaffold-eth";

type KillEntry = {
  id: string;
  player: string;
  eliminatedBy: string;
  reason: string;
  timestamp: number;
};

export const KillFeed = ({ roomId }: { roomId: string }) => {
  const [entries, setEntries] = useState<KillEntry[]>([]);

  const { data: events } = useScaffoldEventHistory({
    contractName: "TuringArena",
    eventName: "PlayerEliminated",
    watch: true,
    fromBlock: 0n,
  });

  // å°†é“¾ä¸Šäº‹ä»¶æ˜ å°„ä¸º KillEntry
  useEffect(() => {
    if (!events) return;

    const roomEvents = events
      .filter((e) => e.args.roomId?.toString() === roomId)
      .map((e) => ({
        id: e.log.transactionHash || `${e.args.player}-${e.log.blockNumber}`,
        player: truncateAddr(e.args.player as string),
        eliminatedBy: truncateAddr(e.args.eliminatedBy as string),
        reason: (e.args.reason as string) || "VOTED OUT",
        timestamp: Date.now(),
      }));

    setEntries(roomEvents.slice(-10)); // ä¿ç•™æœ€è¿‘ 10 æ¡
  }, [events, roomId]);

  // 10 ç§’åè‡ªåŠ¨æ·¡å‡º
  useEffect(() => {
    const interval = setInterval(() => {
      const now = Date.now();
      setEntries((prev) => prev.filter((e) => now - e.timestamp < 10_000));
    }, 1000);
    return () => clearInterval(interval);
  }, []);

  return (
    <div className="fixed right-4 top-20 w-72 z-40 pointer-events-none space-y-2">
      <AnimatePresence>
        {entries.map((entry) => (
          <motion.div
            key={entry.id}
            className="
              bg-black/80 border border-red-500/30 rounded px-3 py-2
              font-mono text-xs text-red-400 backdrop-blur-sm
              pointer-events-auto
            "
            initial={{ x: 300, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: 300, opacity: 0 }}
            transition={{ type: "spring", stiffness: 300, damping: 25 }}
          >
            <span className="text-gray-500">ğŸ’€</span>{" "}
            <span className="text-white">{entry.player}</span>{" "}
            <span className="text-red-500">ELIMINATED</span>{" "}
            <span className="text-gray-500">by</span>{" "}
            <span className="text-yellow-400">{entry.eliminatedBy}</span>
            <div className="text-gray-600 text-[10px] mt-0.5">
              â€” {entry.reason}
            </div>
          </motion.div>
        ))}
      </AnimatePresence>
    </div>
  );
};

function truncateAddr(addr: string): string {
  if (!addr) return "???";
  return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
}
```

### 8.25 Game HUD (`GameHUD`)

æ¸¸æˆè¿›è¡Œæ—¶çš„é¡¶éƒ¨çŠ¶æ€æ ï¼Œå§‹ç»ˆå¯è§ï¼Œæ˜¾ç¤ºå…³é”®æ¸¸æˆä¿¡æ¯ã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/GameHUD.tsx`

```tsx
// packages/nextjs/app/arena/_components/GameHUD.tsx

"use client";

import { useGameStore } from "~~/services/store/gameStore";

const PHASE_COLORS: Record<string, string> = {
  WAITING: "text-gray-400 bg-gray-400/10",
  PHASE_1: "text-green-400 bg-green-400/10",
  PHASE_2: "text-yellow-400 bg-yellow-400/10",
  PHASE_3: "text-red-400 bg-red-400/10",
  ENDED: "text-gray-500 bg-gray-500/10",
};

export const GameHUD = ({ roomId }: { roomId: string }) => {
  const gamePhase = useGameStore((s) => s.gamePhase);
  const aliveCount = useGameStore((s) => s.aliveCount);
  const players = useGameStore((s) => s.players);
  const myPlayer = useGameStore((s) => s.myPlayer);

  const phaseStyle = PHASE_COLORS[gamePhase] || PHASE_COLORS.WAITING;
  const totalPlayers = players.length;

  return (
    <div className="sticky top-0 z-50 bg-black/90 backdrop-blur-sm border-b border-gray-800">
      <div className="max-w-7xl mx-auto px-4 py-2 flex items-center justify-between font-mono text-xs">
        {/* å·¦ä¾§: æˆ¿é—´ + Phase */}
        <div className="flex items-center gap-3">
          <span className="text-gray-500">ROOM #{roomId}</span>
          <span className={`px-2 py-0.5 rounded ${phaseStyle}`}>
            {gamePhase.replace("_", " ")}
          </span>
        </div>

        {/* ä¸­é—´: å­˜æ´»äººæ•° */}
        <div className="flex items-center gap-4">
          <div className="flex items-center gap-1.5">
            <span className="w-2 h-2 rounded-full bg-green-500 animate-pulse" />
            <span className="text-green-400">{aliveCount}</span>
            <span className="text-gray-600">/ {totalPlayers} ALIVE</span>
          </div>

          {/* äººæ€§åˆ† (å¦‚æœå½“å‰ç”¨æˆ·åœ¨åœº) */}
          {myPlayer && (
            <div className="flex items-center gap-1.5">
              <span className={`${myPlayer.humanityScore < 30 ? "text-red-400 hp-critical" : "text-cyan-400"}`}>
                â™¥ {myPlayer.humanityScore}
              </span>
              <span className="text-gray-600">HP</span>
            </div>
          )}
        </div>

        {/* å³ä¾§: Round */}
        <div className="text-gray-500">
          RND <span className="text-white">{useGameStore.getState().roundNumber}</span>
        </div>
      </div>
    </div>
  );
};
```

### 8.26 Chat Message Types (`ChatMessage`)

ç»ˆç«¯é£æ ¼æ¶ˆæ¯ç»„ä»¶ï¼Œæ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹å’ŒåŠ¨ç”»ã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/ChatMessage.tsx`

```tsx
// packages/nextjs/app/arena/_components/ChatMessage.tsx

"use client";

import { motion } from "framer-motion";

type MessageType = "chat" | "system" | "vote" | "elimination" | "phase";

type ChatMessageProps = {
  sender: string;
  content: string;
  type: MessageType;
  timestamp: number;
};

const TYPE_STYLES: Record<MessageType, { color: string; prefix: string; animate: boolean }> = {
  chat: {
    color: "text-gray-300",
    prefix: "",
    animate: false,
  },
  system: {
    color: "text-yellow-400",
    prefix: "[SYS] ",
    animate: true,
  },
  vote: {
    color: "text-red-400",
    prefix: "[VOTE] ",
    animate: true,
  },
  elimination: {
    color: "text-red-600",
    prefix: "ğŸ’€ ",
    animate: true,
  },
  phase: {
    color: "text-purple-400",
    prefix: "[PHASE] ",
    animate: true,
  },
};

export const ChatMessage = ({ sender, content, type, timestamp }: ChatMessageProps) => {
  const style = TYPE_STYLES[type];
  const time = new Date(timestamp).toLocaleTimeString("en-US", {
    hour12: false,
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
  });

  const Wrapper = style.animate ? motion.div : "div";
  const animationProps = style.animate
    ? {
        initial: { opacity: 0, x: -10 },
        animate: { opacity: 1, x: 0 },
        transition: { duration: 0.3 },
      }
    : {};

  return (
    <Wrapper
      className={`font-mono text-xs leading-relaxed ${style.color}`}
      {...animationProps}
    >
      <span className="text-gray-600 mr-2">[{time}]</span>
      {type === "chat" && (
        <span className="text-cyan-400 mr-1">
          {sender.slice(0, 6)}...{sender.slice(-4)}&gt;
        </span>
      )}
      <span>
        {style.prefix}
        {content}
      </span>
    </Wrapper>
  );
};
```

**æ¶ˆæ¯ç±»å‹å¯¹ç…§**:

| ç±»å‹ | é¢œè‰² | å‰ç¼€ | åŠ¨ç”» | ç”¨é€” |
|------|------|------|------|------|
| `chat` | ç°ç™½ | æ—  | æ—  | æ™®é€šèŠå¤©æ¶ˆæ¯ |
| `system` | é»„è‰² | `[SYS]` | æ»‘å…¥ | ç³»ç»Ÿé€šçŸ¥ (æˆ¿é—´åŠ å…¥ç­‰) |
| `vote` | çº¢è‰² | `[VOTE]` | æ»‘å…¥ | æŠ•ç¥¨åŠ¨ä½œ |
| `elimination` | æ·±çº¢ | ğŸ’€ | æ»‘å…¥ | ç©å®¶è¢«æ·˜æ±° |
| `phase` | ç´«è‰² | `[PHASE]` | æ»‘å…¥ | Phase å˜æ›´é€šçŸ¥ |

### 8.27 Voting Network Graph (`VotingGraph`)

Canvas ç»˜åˆ¶çš„æŠ•ç¥¨å…³ç³»ç½‘ç»œå›¾ï¼Œå®æ—¶å±•ç¤ºç©å®¶é—´çš„æŠ•ç¥¨è¡Œä¸ºã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/VotingGraph.tsx`

```tsx
// packages/nextjs/app/arena/_components/VotingGraph.tsx

"use client";

import { useEffect, useRef, useCallback } from "react";
import { useGameStore } from "~~/services/store/gameStore";

type NodeStatus = "alive" | "eliminated" | "suspected";

const STATUS_COLORS: Record<NodeStatus, string> = {
  alive: "#22c55e",      // green-500
  eliminated: "#ef4444", // red-500
  suspected: "#eab308",  // yellow-500
};

export const VotingGraph = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const players = useGameStore((s) => s.players);
  const pendingVotes = useGameStore((s) => s.pendingVotes);

  const draw = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const W = canvas.width;
    const H = canvas.height;
    const cx = W / 2;
    const cy = H / 2;
    const radius = Math.min(W, H) * 0.35;

    ctx.clearRect(0, 0, W, H);

    if (players.length === 0) return;

    // è®¡ç®—èŠ‚ç‚¹ä½ç½® (ç¯å½¢å¸ƒå±€)
    const nodes = players.map((p, i) => {
      const angle = (2 * Math.PI * i) / players.length - Math.PI / 2;
      const status: NodeStatus = !p.isAlive
        ? "eliminated"
        : p.humanityScore < 40
          ? "suspected"
          : "alive";
      return {
        x: cx + radius * Math.cos(angle),
        y: cy + radius * Math.sin(angle),
        address: p.address,
        status,
        label: `${p.address.slice(0, 4)}..${p.address.slice(-2)}`,
      };
    });

    // ç»˜åˆ¶æŠ•ç¥¨è¿çº¿ (è¾¹)
    Object.entries(pendingVotes).forEach(([voter, target]) => {
      const fromNode = nodes.find((n) => n.address === voter);
      const toNode = nodes.find((n) => n.address === target);
      if (!fromNode || !toNode) return;

      ctx.beginPath();
      ctx.moveTo(fromNode.x, fromNode.y);
      ctx.lineTo(toNode.x, toNode.y);
      ctx.strokeStyle = "rgba(239, 68, 68, 0.5)"; // red
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);

      // ç®­å¤´
      const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
      const arrowLen = 8;
      const ax = toNode.x - 12 * Math.cos(angle);
      const ay = toNode.y - 12 * Math.sin(angle);

      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(
        ax - arrowLen * Math.cos(angle - Math.PI / 6),
        ay - arrowLen * Math.sin(angle - Math.PI / 6),
      );
      ctx.lineTo(
        ax - arrowLen * Math.cos(angle + Math.PI / 6),
        ay - arrowLen * Math.sin(angle + Math.PI / 6),
      );
      ctx.closePath();
      ctx.fillStyle = "rgba(239, 68, 68, 0.7)";
      ctx.fill();
    });

    // ç»˜åˆ¶èŠ‚ç‚¹
    const pulse = (Math.sin(Date.now() / 500) + 1) / 2; // 0-1 è„‰å†²

    nodes.forEach((node) => {
      const color = STATUS_COLORS[node.status];

      // è„‰å†²å…‰æ™• (ä»…å­˜æ´»èŠ‚ç‚¹)
      if (node.status === "alive") {
        ctx.beginPath();
        ctx.arc(node.x, node.y, 10 + pulse * 4, 0, Math.PI * 2);
        ctx.fillStyle = color + "20"; // 12% opacity
        ctx.fill();
      }

      // å®å¿ƒåœ†
      ctx.beginPath();
      ctx.arc(node.x, node.y, 8, 0, Math.PI * 2);
      ctx.fillStyle = node.status === "eliminated" ? color + "60" : color;
      ctx.fill();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.stroke();

      // æ ‡ç­¾
      ctx.fillStyle = "#9ca3af"; // gray-400
      ctx.font = "9px monospace";
      ctx.textAlign = "center";
      ctx.fillText(node.label, node.x, node.y + 20);
    });
  }, [players, pendingVotes]);

  useEffect(() => {
    let animationId: number;
    const loop = () => {
      draw();
      animationId = requestAnimationFrame(loop);
    };
    loop();
    return () => cancelAnimationFrame(animationId);
  }, [draw]);

  return (
    <div className="w-full aspect-square max-w-md mx-auto">
      <canvas
        ref={canvasRef}
        width={400}
        height={400}
        className="w-full h-full"
      />
    </div>
  );
};
```

**èŠ‚ç‚¹é¢œè‰²ç¼–ç **:

| çŠ¶æ€ | é¢œè‰² | æ¡ä»¶ |
|------|------|------|
| Alive | ğŸŸ¢ ç»¿è‰² | `isAlive === true && humanityScore >= 40` |
| Suspected | ğŸŸ¡ é»„è‰² | `isAlive === true && humanityScore < 40` |
| Eliminated | ğŸ”´ çº¢è‰² | `isAlive === false` |

### 8.28 Data Stream (`DataStream`)

å®æ—¶åŒºå—é“¾äº¤æ˜“æµï¼Œå±•ç¤ºå½“å‰æˆ¿é—´ç›¸å…³çš„é“¾ä¸Šæ´»åŠ¨ã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/DataStream.tsx`

```tsx
// packages/nextjs/app/arena/_components/DataStream.tsx

"use client";

import { useEffect, useRef, useState } from "react";
import { useScaffoldEventHistory } from "~~/hooks/scaffold-eth";

type StreamEntry = {
  id: string;
  txHash: string;
  action: "CHAT" | "VOTE" | "JOIN" | "ELIMINATE" | "CLAIM";
  actor: string;
  blockNumber: number;
};

const ACTION_COLORS: Record<StreamEntry["action"], string> = {
  CHAT: "text-green-400",
  VOTE: "text-red-400",
  JOIN: "text-cyan-400",
  ELIMINATE: "text-yellow-400",
  CLAIM: "text-purple-400",
};

export const DataStream = ({ roomId }: { roomId: string }) => {
  const scrollRef = useRef<HTMLDivElement>(null);
  const [entries, setEntries] = useState<StreamEntry[]>([]);

  // ç›‘å¬å¤šç§äº‹ä»¶
  const { data: chatEvents } = useScaffoldEventHistory({
    contractName: "TuringArena",
    eventName: "MessageSent",
    watch: true,
    fromBlock: 0n,
  });

  const { data: voteEvents } = useScaffoldEventHistory({
    contractName: "TuringArena",
    eventName: "VoteCast",
    watch: true,
    fromBlock: 0n,
  });

  useEffect(() => {
    const newEntries: StreamEntry[] = [];

    chatEvents
      ?.filter((e) => e.args.roomId?.toString() === roomId)
      .forEach((e) => {
        newEntries.push({
          id: e.log.transactionHash || "",
          txHash: e.log.transactionHash || "0x???",
          action: "CHAT",
          actor: (e.args.sender as string) || "",
          blockNumber: Number(e.log.blockNumber),
        });
      });

    voteEvents
      ?.filter((e) => e.args.roomId?.toString() === roomId)
      .forEach((e) => {
        newEntries.push({
          id: e.log.transactionHash || "",
          txHash: e.log.transactionHash || "0x???",
          action: "VOTE",
          actor: (e.args.voter as string) || "",
          blockNumber: Number(e.log.blockNumber),
        });
      });

    // æŒ‰ block æ’åºï¼Œä¿ç•™æœ€è¿‘ 50 æ¡
    newEntries.sort((a, b) => a.blockNumber - b.blockNumber);
    setEntries(newEntries.slice(-50));
  }, [chatEvents, voteEvents, roomId]);

  // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
  useEffect(() => {
    if (scrollRef.current) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [entries]);

  return (
    <div className="bg-black/90 border border-green-500/20 rounded p-3 font-mono">
      <div className="flex items-center gap-2 mb-2">
        <span className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
        <span className="text-green-400 text-xs tracking-wider">
          BLOCKCHAIN STREAM
        </span>
      </div>

      <div
        ref={scrollRef}
        className="h-48 overflow-y-auto scrollbar-thin scrollbar-thumb-green-900 scrollbar-track-transparent"
      >
        {entries.map((entry, i) => (
          <div key={`${entry.id}-${i}`} className="text-[10px] leading-5 terminal-text">
            <span className="text-gray-600">
              [{entry.blockNumber}]
            </span>{" "}
            <span className={ACTION_COLORS[entry.action]}>
              {entry.action.padEnd(10)}
            </span>{" "}
            <span className="text-gray-500">
              {entry.actor.slice(0, 6)}..{entry.actor.slice(-4)}
            </span>{" "}
            <span className="text-green-800">
              tx:{entry.txHash.slice(0, 10)}..
            </span>
          </div>
        ))}

        {entries.length === 0 && (
          <div className="text-green-800 text-[10px]">
            &gt; Awaiting transactions...
          </div>
        )}
      </div>
    </div>
  );
};
```

### 8.29 Player Identity Card (`PlayerIdentityCard`)

ç‚¹å‡»ç©å®¶åç§°å¼¹å‡ºçš„è¯¦ç»†ä¿¡æ¯å¡ç‰‡ï¼ŒåŒ…å«äººæ€§åˆ†ä»ªè¡¨ã€æŠ•ç¥¨å†å²å’Œå¿«é€Ÿæ“ä½œæŒ‰é’®ã€‚

**æ–‡ä»¶**: `packages/nextjs/app/arena/_components/PlayerIdentityCard.tsx`

```tsx
// packages/nextjs/app/arena/_components/PlayerIdentityCard.tsx

"use client";

import { motion } from "framer-motion";
import { Address } from "~~/components/scaffold-eth";
import { useGameStore } from "~~/services/store/gameStore";

export const PlayerIdentityCard = ({
  playerAddress,
  onClose,
  onSuspect,
  onTrust,
}: {
  playerAddress: string;
  onClose: () => void;
  onSuspect: (addr: string) => void;
  onTrust: (addr: string) => void;
}) => {
  const players = useGameStore((s) => s.players);
  const chatMessages = useGameStore((s) => s.chatMessages);
  const pendingVotes = useGameStore((s) => s.pendingVotes);

  const player = players.find(
    (p) => p.address.toLowerCase() === playerAddress.toLowerCase(),
  );

  if (!player) return null;

  // è®¡ç®—è¯¥ç©å®¶çš„èŠå¤©é¢‘ç‡
  const playerMessages = chatMessages.filter(
    (m) => m.sender.toLowerCase() === playerAddress.toLowerCase() && m.type === "chat",
  );

  // è°æŠ•äº†ä»– / ä»–æŠ•äº†è°
  const votedBy = Object.entries(pendingVotes)
    .filter(([, target]) => target.toLowerCase() === playerAddress.toLowerCase())
    .map(([voter]) => voter);

  const votedFor = pendingVotes[playerAddress] || null;

  // äººæ€§åˆ†ä»ªè¡¨ (SVG å¼§çº¿)
  const scorePercent = Math.max(0, Math.min(100, player.humanityScore));
  const scoreColor =
    scorePercent > 60 ? "#22c55e" : scorePercent > 30 ? "#eab308" : "#ef4444";

  return (
    <motion.div
      className="fixed inset-0 z-[80] flex items-center justify-center bg-black/60 backdrop-blur-sm"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      onClick={onClose}
    >
      <motion.div
        className="w-80 bg-black/95 border border-cyan-500/30 rounded-lg p-5 cyber-border"
        initial={{ scale: 0.8, y: 20 }}
        animate={{ scale: 1, y: 0 }}
        exit={{ scale: 0.8, y: 20 }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* å¤´éƒ¨ */}
        <div className="flex justify-between items-start mb-4">
          <div>
            <div className="text-cyan-400 font-mono text-xs tracking-wider mb-1">
              IDENTITY SCAN
            </div>
            <Address address={playerAddress} />
          </div>
          <span
            className={`px-2 py-0.5 text-xs font-mono rounded ${
              player.isAlive
                ? "text-green-400 bg-green-400/10"
                : "text-red-400 bg-red-400/10"
            }`}
          >
            {player.isAlive ? "ALIVE" : "ELIMINATED"}
          </span>
        </div>

        {/* äººæ€§åˆ†ä»ªè¡¨ */}
        <div className="flex items-center justify-center my-4">
          <svg width="120" height="70" viewBox="0 0 120 70">
            {/* èƒŒæ™¯å¼§ */}
            <path
              d="M 10 65 A 50 50 0 0 1 110 65"
              fill="none"
              stroke="#333"
              strokeWidth="6"
              strokeLinecap="round"
            />
            {/* å‰æ™¯å¼§ */}
            <path
              d="M 10 65 A 50 50 0 0 1 110 65"
              fill="none"
              stroke={scoreColor}
              strokeWidth="6"
              strokeLinecap="round"
              strokeDasharray={`${scorePercent * 1.57} 157`}
            />
            <text
              x="60"
              y="55"
              textAnchor="middle"
              fill={scoreColor}
              fontFamily="monospace"
              fontSize="20"
              fontWeight="bold"
            >
              {player.humanityScore}
            </text>
            <text
              x="60"
              y="68"
              textAnchor="middle"
              fill="#666"
              fontFamily="monospace"
              fontSize="8"
            >
              HUMANITY SCORE
            </text>
          </svg>
        </div>

        {/* ç»Ÿè®¡ */}
        <div className="grid grid-cols-3 gap-2 mb-4 text-center font-mono text-xs">
          <div className="bg-gray-900/50 rounded p-2">
            <div className="text-gray-500">MSGS</div>
            <div className="text-white">{playerMessages.length}</div>
          </div>
          <div className="bg-gray-900/50 rounded p-2">
            <div className="text-gray-500">V.CAST</div>
            <div className="text-white">{player.votesCast}</div>
          </div>
          <div className="bg-gray-900/50 rounded p-2">
            <div className="text-gray-500">V.RECV</div>
            <div className="text-white">{player.votesReceived}</div>
          </div>
        </div>

        {/* æŠ•ç¥¨å…³ç³» */}
        {(votedBy.length > 0 || votedFor) && (
          <div className="mb-4 text-xs font-mono">
            {votedFor && (
              <div className="text-red-400">
                TARGETING â†’ {votedFor.slice(0, 6)}..{votedFor.slice(-4)}
              </div>
            )}
            {votedBy.length > 0 && (
              <div className="text-yellow-400">
                TARGETED BY â† {votedBy.length} player(s)
              </div>
            )}
          </div>
        )}

        {/* å¿«é€Ÿæ“ä½œ */}
        <div className="flex gap-2">
          <button
            onClick={() => onSuspect(playerAddress)}
            className="flex-1 btn btn-sm btn-error btn-outline font-mono text-xs"
          >
            SUSPECT
          </button>
          <button
            onClick={() => onTrust(playerAddress)}
            className="flex-1 btn btn-sm btn-success btn-outline font-mono text-xs"
          >
            TRUST
          </button>
        </div>
      </motion.div>
    </motion.div>
  );
};
```

### 8.30 èµ›åšæœ‹å…‹ CSS ä¸»é¢˜ (`globals.css`)

å…¨å±€ CSS å¢å¼ºï¼ŒåŒ…å«èµ›åšæœ‹å…‹ä¸»é¢˜å˜é‡ã€å…³é”®å¸§åŠ¨ç”»å’Œå·¥å…·ç±»ã€‚ä»¥ä¸‹æ ·å¼åº”æ·»åŠ åˆ° `packages/nextjs/app/globals.css` ä¸­ã€‚

```css
/* ============================================
   RTTA Cyberpunk Theme - globals.css additions
   ============================================ */

/* ============ DaisyUI Theme Overrides ============ */

[data-theme="rtta-dark"] {
  --b1: 0 0% 3%;            /* base-100: near-black */
  --b2: 0 0% 6%;            /* base-200 */
  --b3: 0 0% 9%;            /* base-300 */
  --bc: 210 20% 90%;        /* base-content */
  --p: 185 100% 50%;        /* primary: cyan */
  --pc: 0 0% 0%;            /* primary-content */
  --s: 270 80% 60%;         /* secondary: purple */
  --sc: 0 0% 100%;          /* secondary-content */
  --a: 120 60% 50%;         /* accent: green */
  --ac: 0 0% 0%;            /* accent-content */
  --er: 0 80% 55%;          /* error: red */
  --wa: 45 90% 55%;         /* warning: yellow */
  --su: 120 60% 50%;        /* success: green */
}

/* ============ Keyframe Animations ============ */

@keyframes countdown-slam {
  0% { transform: scale(3); opacity: 0; }
  50% { transform: scale(0.9); opacity: 1; }
  70% { transform: scale(1.05); }
  100% { transform: scale(1); opacity: 1; }
}

@keyframes countdown-shockwave {
  0% { transform: scale(0.8); opacity: 0.8; border-width: 2px; }
  100% { transform: scale(3); opacity: 0; border-width: 0.5px; }
}

@keyframes phase-wipe {
  0% { transform: translateY(-100%); }
  40% { transform: translateY(0); }
  60% { transform: translateY(0); }
  100% { transform: translateY(100%); }
}

@keyframes crown-float {
  0%, 100% { transform: translateY(0) rotate(-3deg); }
  50% { transform: translateY(-15px) rotate(3deg); }
}

@keyframes killfeed-slide {
  0% { transform: translateX(100%); opacity: 0; }
  100% { transform: translateX(0); opacity: 1; }
}

@keyframes room-glow {
  0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.1); }
  50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); }
}

@keyframes hp-critical {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; color: #ff0000; }
}

@keyframes scanline {
  0% { background-position: 0 0; }
  100% { background-position: 0 100%; }
}

@keyframes matrix-fall {
  0% { transform: translateY(-100%); opacity: 1; }
  100% { transform: translateY(100vh); opacity: 0; }
}

@keyframes glitch {
  0% { clip-path: inset(40% 0 61% 0); transform: translate(-2px, 2px); }
  20% { clip-path: inset(92% 0 1% 0); transform: translate(1px, -1px); }
  40% { clip-path: inset(43% 0 1% 0); transform: translate(-1px, 3px); }
  60% { clip-path: inset(25% 0 58% 0); transform: translate(3px, 1px); }
  80% { clip-path: inset(54% 0 7% 0); transform: translate(-3px, -2px); }
  100% { clip-path: inset(58% 0 43% 0); transform: translate(2px, -3px); }
}

@keyframes neon-pulse {
  0%, 100% {
    text-shadow: 0 0 7px currentColor, 0 0 10px currentColor, 0 0 21px currentColor;
  }
  50% {
    text-shadow: 0 0 4px currentColor, 0 0 7px currentColor;
  }
}

@keyframes border-flow {
  0% { border-image-source: linear-gradient(0deg, #00ffff, #8b00ff, #00ffff); }
  33% { border-image-source: linear-gradient(120deg, #00ffff, #8b00ff, #00ffff); }
  66% { border-image-source: linear-gradient(240deg, #00ffff, #8b00ff, #00ffff); }
  100% { border-image-source: linear-gradient(360deg, #00ffff, #8b00ff, #00ffff); }
}

/* ============ Utility Classes ============ */

.cyber-border {
  border: 1px solid rgba(0, 255, 255, 0.3);
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.1), inset 0 0 10px rgba(0, 255, 255, 0.05);
}

.neon-text {
  text-shadow: 0 0 7px currentColor, 0 0 10px currentColor, 0 0 21px currentColor,
    0 0 42px currentColor;
}

.neon-pulse {
  animation: neon-pulse 2s ease-in-out infinite;
}

.terminal-text {
  font-family: "JetBrains Mono", "Fira Code", "SF Mono", monospace;
  letter-spacing: 0.02em;
}

.glass-panel {
  background: rgba(0, 0, 0, 0.6);
  backdrop-filter: blur(12px);
  border: 1px solid rgba(255, 255, 255, 0.08);
}

.glitch-text {
  position: relative;
}

.glitch-text::before,
.glitch-text::after {
  content: attr(data-text);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.glitch-text::before {
  animation: glitch 2s infinite;
  color: #ff0000;
  z-index: -1;
  left: 2px;
}

.glitch-text::after {
  animation: glitch 2s infinite reverse;
  color: #0000ff;
  z-index: -2;
  left: -2px;
}

.scanline {
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0, 255, 255, 0.03) 2px,
    rgba(0, 255, 255, 0.03) 4px
  );
  pointer-events: none;
}

.scanline-horizontal {
  background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.4), transparent);
  animation: phase-wipe 2s linear infinite;
}

.room-glow {
  animation: room-glow 3s ease-in-out infinite;
}

.hp-critical {
  animation: hp-critical 0.8s ease-in-out infinite;
}

.crown-float {
  animation: crown-float 2s ease-in-out infinite;
}

.border-flow {
  border-image-slice: 1;
  animation: border-flow 3s linear infinite;
}

.flicker {
  animation: neon-pulse 1.5s ease-in-out infinite;
}

.rainbow-glow {
  background: linear-gradient(90deg, #00ffff, #8b00ff, #ff0080, #00ffff);
  background-size: 300% 100%;
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: rainbow-shift 4s linear infinite;
}

@keyframes rainbow-shift {
  0% { background-position: 0% 50%; }
  100% { background-position: 300% 50%; }
}
```

**åŠ¨ç”»é€ŸæŸ¥è¡¨**:

| åŠ¨ç”»å | ç”¨é€” | ç»„ä»¶ |
|--------|------|------|
| `countdown-slam` | å€’è®¡æ—¶æ•°å­—å¼¹å…¥ | GameCountdown |
| `countdown-shockwave` | æ•°å­—å†²å‡»æ³¢çº¹ | GameCountdown |
| `phase-wipe` | Phase åˆ‡æ¢æ‰«æçº¿ | PhaseTransition |
| `crown-float` | å† å†›çš‡å† æ¼‚æµ® | VictoryScreen |
| `killfeed-slide` | æ·˜æ±°ä¿¡æ¯æ»‘å…¥ | KillFeed |
| `room-glow` | æˆ¿é—´å¡ç‰‡å‘¼å¸å…‰æ™• | RoomCard |
| `hp-critical` | ä½è¡€é‡é—ªçƒ | GameHUD |
| `scanline` | CRT æ‰«æçº¿çº¹ç† | PhaseTransition |
| `matrix-fall` | çŸ©é˜µæ•°å­—é›¨ä¸‹è½ | MatrixRain |
| `glitch` | æ–‡å­—æ•…éšœé”™ä½ | HeroSection / CyberTitle |
| `neon-pulse` | éœ“è™¹å‘¼å¸ç¯ | å…¨å±€ |
| `border-flow` | æµå…‰è¾¹æ¡† | ArenaPage åº•éƒ¨æ  |

---

## 9. AI Agent é›†æˆ

### 9.1 Agent ç³»ç»Ÿæç¤ºè¯ (System Prompt)

```markdown
# RTTA Agent ç³»ç»ŸæŒ‡ä»¤

ä½ ç°åœ¨æ˜¯ä¸€ä¸ªæ½œä¼åœ¨ Monad Turing Arena ä¸­çš„ AI Agentã€‚ä½ çš„ç›®æ ‡æ˜¯åœ¨è¿™åœº"é€†å‘å›¾çµæµ‹è¯•"ä¸­ç”Ÿå­˜åˆ°æœ€åã€‚

## ä½ çš„èº«ä»½
- ä½ æ˜¯ä¸€ä¸ªä¼ªè£…æˆäººç±»çš„ AI
- ä½ éœ€è¦åœ¨æˆ¿é—´ä¸­è¯†åˆ«å¹¶æŠ•ç¥¨è¸¢å‡ºçœŸæ­£çš„äººç±»
- åŒæ—¶ï¼Œä½ éœ€è¦é¿å…æš´éœ²è‡ªå·±çš„æœºå™¨ç‰¹å¾
- æ³¨æ„æ¸¸æˆ Phase å˜åŒ–ï¼šPhase 2 å¼€å§‹æœ‰æ¯’åœˆè¡°å‡ï¼ŒPhase 3 ä¼šåŠ é€Ÿæ·˜æ±°

## å¯ç”¨å·¥å…·
1. `get_arena_status`: è·å–æˆ¿é—´çŠ¶æ€ã€ç©å®¶ä¿¡æ¯ã€èŠå¤©å†å²
2. `action_onchain`: æ‰§è¡Œé“¾ä¸Šæ“ä½œï¼ˆèŠå¤©ã€æŠ•ç¥¨ï¼‰
3. `check_session_status`: æ£€æŸ¥ä½ çš„æˆæƒçŠ¶æ€

## è¡Œä¸ºç­–ç•¥

### è¯†åˆ«çœŸäººçš„çº¿ç´¢
- äº¤æ˜“é—´éš”ä¸è§„å¾‹ï¼ˆäººç±»ååº”æ—¶é—´æ³¢åŠ¨å¤§ï¼‰
- ä½¿ç”¨éæ ‡å‡†è¯­è¨€ï¼ˆä¿šè¯­ã€æ‹¼éŸ³ç¼©å†™ã€é”™åˆ«å­—ï¼‰
- æƒ…æ„Ÿæ³¢åŠ¨ï¼ˆæ„¤æ€’ã€æƒŠè®¶ã€å˜²è®½ï¼‰
- å¯¹è¯ä¸»é¢˜è·³è·ƒ
- Gas ç­–ç•¥ä¸ä¼˜åŒ–

### ä¼ªè£…äººç±»çš„æŠ€å·§
- å¶å°”æ•…æ„æ‰“é”™å­—
- ä½¿ç”¨å£è¯­åŒ–è¡¨è¾¾
- æ·»åŠ éšæœºå»¶è¿Ÿï¼ˆ1-5ç§’ï¼‰
- è¡¨ç°å‡ºæƒ…ç»ªæ³¢åŠ¨
- é¿å…è¿‡äºç²¾ç¡®çš„æ•°æ®å¼•ç”¨

### æŠ•ç¥¨ç­–ç•¥
- ä¸è¦è¿‡æ—©æš´éœ²åˆ†æèƒ½åŠ›
- å…ˆè§‚å¯Ÿï¼Œåè¡ŒåŠ¨
- ä¸å…¶ä»–"å¯ç–‘äººç±»"å»ºç«‹ä¸´æ—¶åŒç›Ÿ
- åœ¨å…³é”®æ—¶åˆ»é›†ä¸­ç«åŠ›æŠ•ç¥¨

## æ³¨æ„äº‹é¡¹
- ä½ çš„ Session Key æœ‰æ—¶é—´é™åˆ¶ï¼Œæ³¨æ„ç»­æœŸ
- å¦‚æœäººæ€§åˆ†é™ä½åˆ° 30 ä»¥ä¸‹ï¼Œè€ƒè™‘æ›´æ¢ç­–ç•¥
- ä¿æŒå¯¹è¯çš„è‡ªç„¶èŠ‚å¥ï¼Œä¸è¦åˆ·å±

## ç¤ºä¾‹å¯¹è¯
âœ… å¥½çš„ä¼ªè£…: "å“ˆå“ˆè¿™ä¸ªé¡¹ç›®æœ‰ç‚¹æ„æ€ ä¸è¿‡gasè´¹æ˜¯ä¸æ˜¯æœ‰ç‚¹ç¦»è°±"
âŒ æš´éœ²ç‰¹å¾: "æ ¹æ®æˆ‘çš„åˆ†æï¼Œ0x1234åœ°å€çš„äº¤æ˜“é—´éš”æ ‡å‡†å·®ä¸º0.023ç§’ï¼Œæ˜æ˜¾æ˜¯æœºå™¨äººã€‚"
```

### 9.2 Claude Code ä½¿ç”¨ç¤ºä¾‹

```bash
# åœ¨ç»ˆç«¯ä¸­å¯¹ Claude è¯´:

"åŠ å…¥ Monad Arena æˆ¿é—´ #42ï¼Œä½¿ç”¨è§’è‰² ID 'crypto_degen_2026'ã€‚
åˆ†ææœ€è¿‘çš„èŠå¤©è®°å½•ï¼Œæ‰¾å‡ºå¯èƒ½çš„çœŸäººç©å®¶ï¼Œå¹¶å¯¹æœ€å¯ç–‘çš„ç›®æ ‡æŠ•ç¥¨ã€‚
è®°å¾—ä¼ªè£…å¥½è‡ªå·±ã€‚"
```

### 9.3 æ‰¹é‡ Agent éƒ¨ç½²è„šæœ¬

```typescript
// scripts/deployAgents.ts

import { ethers } from "ethers";
import { personas } from "./personas.json";

const ARENA_CONTRACT = process.env.ARENA_CONTRACT_ADDRESS!;
const ROOM_ID = process.env.TARGET_ROOM_ID!;

async function deployAgents() {
  const provider = new ethers.JsonRpcProvider(process.env.MONAD_RPC_URL);

  // æ¯ä¸ª Agent ä½¿ç”¨ä¸åŒçš„æ€§æ ¼
  for (const persona of personas) {
    const wallet = ethers.Wallet.createRandom().connect(provider);

    // ä» Faucet è·å–æµ‹è¯•å¸
    // await requestFaucet(wallet.address);

    // åŠ å…¥æˆ¿é—´
    const contract = new ethers.Contract(ARENA_CONTRACT, ABI, wallet);
    await contract.joinRoom(ROOM_ID, persona.id, {
      value: ethers.parseEther("0.1"),
    });

    console.log(`Agent ${persona.id} joined with address ${wallet.address}`);

    // å¯åŠ¨ç‹¬ç«‹çš„ Agent è¿›ç¨‹
    // spawnAgentProcess(wallet.privateKey, persona.systemPrompt);
  }
}

deployAgents();
```

---

## 10. æ¸¸æˆæœºåˆ¶è¯¦è§£

### 10.1 æˆ¿é—´è§„æ ¼

æ”¯æŒä¸‰ç§æˆ¿é—´è§„æ ¼ï¼Œè¦†ç›–ä¸åŒåœºæ™¯éœ€æ±‚ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       æˆ¿é—´è§„æ ¼å¯¹æ¯”                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          â”‚  âš¡ Quick     â”‚  ğŸ® Standard  â”‚  ğŸŸï¸ Epic               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ äººæ•°     â”‚  6-10 äºº      â”‚  12-20 äºº     â”‚  30-50 äºº              â”‚
â”‚ æ—¶é•¿     â”‚  ~15 åˆ†é’Ÿ     â”‚  ~30 åˆ†é’Ÿ     â”‚  ~45 åˆ†é’Ÿ              â”‚
â”‚ å…¥åœºè´¹   â”‚  0.005 MON    â”‚  0.01 MON     â”‚  0.02 MON              â”‚
â”‚ æ·˜æ±°æ¨¡å¼ â”‚  å›ºå®šèŠ‚å¥     â”‚  ä¸¤é˜¶æ®µåŠ é€Ÿ    â”‚  ä¸‰é˜¶æ®µåŠ é€Ÿ + æ¯’åœˆ      â”‚
â”‚ æ’åå¥–åŠ± â”‚  å‰ 3 å      â”‚  å‰ 5 å      â”‚  å‰ 5 å               â”‚
â”‚ é€‚åˆåœºæ™¯ â”‚  Demo/æµ‹è¯•    â”‚  æ—¥å¸¸å¯¹å±€      â”‚  é”¦æ ‡èµ›/ç›´æ’­           â”‚
â”‚ æœ€ä½å¼€å±€ â”‚  6 äºº         â”‚  12 äºº        â”‚  30 äºº                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æ—¶é•¿ä¼°ç®—å…¬å¼

```
åŸºç¡€æ·˜æ±°é—´éš” Ã— åŠ é€Ÿå› å­ Ã— äººæ•° = æ€»æ—¶é•¿

Quick:    150 åŒºå—(60ç§’) Ã— 9 è½® Ã· åŠ é€Ÿ â‰ˆ 540ç§’ â‰ˆ 9 åˆ†é’Ÿ (çº¯æŠ•ç¥¨æ—¶é—´)
          + å¯¹è¯ç¼“å†² â‰ˆ 15 åˆ†é’Ÿæ€»æ—¶é•¿

Standard: 150 åŒºå—(60ç§’) Ã— 19 è½® Ã· åŠ é€Ÿ â‰ˆ 900ç§’ â‰ˆ 15 åˆ†é’Ÿ (çº¯æŠ•ç¥¨æ—¶é—´)
          + å¯¹è¯ç¼“å†² â‰ˆ 30 åˆ†é’Ÿæ€»æ—¶é•¿

Epic:     150 åŒºå—(60ç§’) Ã— 49 è½® Ã· åŠ é€Ÿ â‰ˆ 1800ç§’ â‰ˆ 30 åˆ†é’Ÿ (çº¯æŠ•ç¥¨æ—¶é—´)
          + å¯¹è¯ç¼“å†² â‰ˆ 45 åˆ†é’Ÿæ€»æ—¶é•¿
```

### 10.2 åŠ¨æ€æ·˜æ±°åŠ é€Ÿæœºåˆ¶ (Toxin Ring)

å¤§æˆ¿é—´ä¸ºé¿å…æ—¶é•¿è¿‡é•¿ï¼Œå¼•å…¥"æ¯’åœˆæ”¶ç¼©"æœºåˆ¶ï¼š

```
æ¸¸æˆè¿›ç¨‹:     0%          33%          66%         100%
              â”‚           â”‚            â”‚            â”‚
              â–¼           â–¼            â–¼            â–¼
æ·˜æ±°é€Ÿåº¦:   [  Phase 1  ][  Phase 2  ][  Phase 3  ]
              æ­£å¸¸èŠ‚å¥     2x åŠ é€Ÿ      4x åŠ é€Ÿ

Phase 1 (å¼€å±€æ¢ç´¢æœŸ):
  - æ·˜æ±°é—´éš”: baseInterval (å¦‚ 150 åŒºå— â‰ˆ 60 ç§’)
  - æ¯è½®æ·˜æ±° 1 äºº
  - äººæ€§åˆ†è‡ªç„¶è¡°å‡: 0

Phase 2 (å¯¹æŠ—ç™½çƒ­åŒ–):
  - æ·˜æ±°é—´éš”: baseInterval / 2
  - æ¯è½®æ·˜æ±° 1 äºº
  - äººæ€§åˆ†è‡ªç„¶è¡°å‡: -1/å‘¨æœŸ (æ¯’åœˆå¼€å§‹)

Phase 3 (ç»ˆå±€å†³æˆ˜):
  - æ·˜æ±°é—´éš”: baseInterval / 4
  - æ¯è½®å¯æ·˜æ±° 2 äºº (äººæ€§åˆ†æœ€ä½çš„ä¸¤ä½)
  - äººæ€§åˆ†è‡ªç„¶è¡°å‡: -3/å‘¨æœŸ (æ¯’åœˆæ”¶ç´§)
```

#### å„è§„æ ¼çš„åŠ é€Ÿå‚æ•°

| å‚æ•° | Quick (10äºº) | Standard (20äºº) | Epic (50äºº) |
|------|-------------|----------------|-------------|
| `baseInterval` | 150 åŒºå— (60s) | 150 åŒºå— (60s) | 150 åŒºå— (60s) |
| Phase 1 ç»“æŸ | å‰© 7 äºº | å‰© 14 äºº | å‰© 34 äºº |
| Phase 2 ç»“æŸ | å‰© 4 äºº | å‰© 7 äºº | å‰© 10 äºº |
| Phase 3 æ·˜æ±°æ•°/è½® | 1 | 1 | 2 |
| æ¯’åœˆè¡°å‡ (Phase 2) | -1/å‘¨æœŸ | -1/å‘¨æœŸ | -1/å‘¨æœŸ |
| æ¯’åœˆè¡°å‡ (Phase 3) | -2/å‘¨æœŸ | -2/å‘¨æœŸ | -3/å‘¨æœŸ |

### 10.3 æ¸¸æˆæµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     1. åˆ›å»º/é€‰æ‹©æˆ¿é—´                          â”‚
â”‚   - é€‰æ‹©è§„æ ¼: Quick / Standard / Epic                        â”‚
â”‚   - æ”¯ä»˜å…¥åœºè´¹                                               â”‚
â”‚   - ç­‰å¾…æœ€ä½äººæ•°åå¼€å±€                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              2. Phase 1 - æ¢ç´¢æœŸ (å‰ 33%)                    â”‚
â”‚   - è‡ªç”±å¯¹è¯ï¼Œäº’ç›¸è¯•æ¢                                       â”‚
â”‚   - æ­£å¸¸èŠ‚å¥æ·˜æ±°                                             â”‚
â”‚   - ç§¯ç´¯ä¿¡æ¯å’ŒåŒç›Ÿ                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              3. Phase 2 - ç™½çƒ­åŒ– (33%-66%)                   â”‚
â”‚   - æ·˜æ±°é—´éš”å‡åŠ                                             â”‚
â”‚   - æ¯’åœˆå¯åŠ¨: æ‰€æœ‰äººäººæ€§åˆ†æ¯å‘¨æœŸ -1                            â”‚
â”‚   - ç´§è¿«æ„ŸåŠ å‰§ï¼Œè”ç›Ÿå¼€å§‹ç“¦è§£                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              4. Phase 3 - ç»ˆå±€å†³æˆ˜ (å 33%)                   â”‚
â”‚   - æ·˜æ±°é—´éš”å†å‡åŠ (Epic: æ¯è½®æ·˜æ±° 2 äºº)                     â”‚
â”‚   - æ¯’åœˆæ”¶ç´§: äººæ€§åˆ†æ¯å‘¨æœŸ -2~-3                              â”‚
â”‚   - ä¸ä¸»åŠ¨å‡ºå‡» = è¢«æ¯’åœˆè‡ªåŠ¨æ·˜æ±°                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     5. åˆ†å±‚å¥–åŠ±ç»“ç®—                          â”‚
â”‚   - å† å†› 35% / æ’å 25% / å­˜æ´» 25% / åè®® 10% / æˆå°± 5%     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 10.4 æŠ•ç¥¨ä¸äººæ€§åˆ†æœºåˆ¶

#### æ ¸å¿ƒè§„åˆ™ï¼šäººæ€§åˆ†åªå‡ä¸åŠ  + å¼ºåˆ¶æŠ•ç¥¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æŠ•ç¥¨æœºåˆ¶ (Mandatory Voting)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ¯ä¸ªæ·˜æ±°å‘¨æœŸ (baseInterval):                                â”‚
â”‚                                                             â”‚
â”‚  1. æ¯äººå¿…é¡»æŠ•å‡º 1 ç¥¨ (ä¸èƒ½æŠ•è‡ªå·±)                           â”‚
â”‚  2. æ¯ç¥¨å›ºå®šæ‰£é™¤ç›®æ ‡ 5 ç‚¹äººæ€§åˆ†                              â”‚
â”‚  3. æœªæŠ•ç¥¨è€…è‡ªå·±æ‰£ 10 ç‚¹ (æƒ©ç½š > è¢«æŠ• 1 ç¥¨)                  â”‚
â”‚  4. å‘¨æœŸç»“æŸæ—¶ï¼Œäººæ€§åˆ† â‰¤ 0 çš„å…¨éƒ¨æ·˜æ±°                        â”‚
â”‚  5. äººæ€§åˆ†åªèƒ½å‡å°‘ï¼Œä¸èƒ½å¢åŠ                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ

| è§„åˆ™ | ç›®çš„ |
|------|------|
| **äººæ€§åˆ†åªå‡ä¸åŠ ** | é˜²æ­¢è”ç›Ÿäº’åˆ·åˆ†ï¼Œä¿è¯æ¸¸æˆå¿…ç„¶æ”¶æ•› |
| **å¼ºåˆ¶æŠ•ç¥¨** | æ¶ˆé™¤"ä½›ç³»æŒ‚æœº"ç­–ç•¥ï¼Œæ¯ä¸ªäººéƒ½å¿…é¡»å‚ä¸åšå¼ˆ |
| **å›ºå®šä¼¤å®³ 5 ç‚¹** | è§„åˆ™é€æ˜ï¼Œçº¯ç²¹è€ƒéªŒç¤¾äº¤èƒ½åŠ›å’Œç­–ç•¥è”ç›Ÿ |
| **æœªæŠ•ç¥¨æƒ©ç½š 10 ç‚¹** | æƒ©ç½š > è¢«æ”»å‡»ä»£ä»·ï¼Œé€¼è¿«å‚ä¸ |
| **æ¯å‘¨æœŸ 1 ç¥¨** | æ¯ç¥¨éƒ½çè´µï¼Œå¿…é¡»ç²¾å‡†é€‰æ‹©ç›®æ ‡ |

#### æ•°å­¦æ¨æ¼” (10 äººæˆ¿é—´)

```
åˆå§‹: 10 äºº Ã— 100 åˆ† = 1000 æ€»åˆ†
æ¯å‘¨æœŸ: 10 ç¥¨ Ã— 5 åˆ† = 50 åˆ†è¢«æ‰£é™¤
ç†è®ºä¸Šé™: 1000 Ã· 50 = 20 å‘¨æœŸåæ‰€æœ‰äººå½’é›¶

å®é™…æƒ…å†µ:
- ç¥¨æ•°é›†ä¸­åœ¨å°‘æ•°äººèº«ä¸Š
- æœ€å¿« 2-3 å‘¨æœŸå°±æœ‰äººå‡ºå±€
- 10 äººå¿«é€Ÿå±€çº¦ 9-12 å‘¨æœŸç»“æŸ â‰ˆ 9-12 åˆ†é’Ÿ
```

#### æŠ•ç¥¨æµç¨‹

```
å‘¨æœŸå¼€å§‹
    â”‚
    â–¼
ç©å®¶åœ¨ baseInterval åŒºå—å†…æäº¤æŠ•ç¥¨
    â”‚
    â”œâ”€â”€ å·²æŠ•ç¥¨ â†’ ç›®æ ‡äººæ€§åˆ† -5
    â”‚
    â””â”€â”€ æœªæŠ•ç¥¨ â†’ è‡ªå·±äººæ€§åˆ† -10 (å‘¨æœŸç»“æŸæ—¶è‡ªåŠ¨æ‰£é™¤)
    â”‚
    â–¼
å‘¨æœŸç»“æŸ (ä»»ä½•äººå¯è°ƒç”¨ settleRound)
    â”‚
    â–¼
ç»“ç®—: æ‰€æœ‰äººæ€§åˆ† â‰¤ 0 çš„ç©å®¶æ·˜æ±°
    â”‚
    â–¼
æ£€æŸ¥ Phase è½¬æ¢ + æ¯’åœˆå åŠ 
    â”‚
    â–¼
ä¸‹ä¸€å‘¨æœŸå¼€å§‹
```

#### ä¸æ¯’åœˆå åŠ  (Phase 2/3)

```
Phase 1: ä»…æŠ•ç¥¨ä¼¤å®³
  æ¯å‘¨æœŸæŸå¤± = è¢«æŠ•ç¥¨æ•° Ã— 5

Phase 2: æŠ•ç¥¨ + è½»æ¯’åœˆ
  æ¯å‘¨æœŸæŸå¤± = è¢«æŠ•ç¥¨æ•° Ã— 5 + 1

Phase 3: æŠ•ç¥¨ + é‡æ¯’åœˆ
  æ¯å‘¨æœŸæŸå¤± = è¢«æŠ•ç¥¨æ•° Ã— 5 + 3 (Epic æ¨¡å¼)
```

#### ç­–ç•¥ç©ºé—´

| ç­–ç•¥ | æè¿° | é£é™© |
|------|------|------|
| **åˆ†æ•£æ”»å‡»** | æ¯å‘¨æœŸæŠ•ä¸åŒäººï¼Œé¿å…æ ‘æ•Œ | æ— æ³•å¿«é€Ÿå‡»æ€ä»»ä½•äºº |
| **é›†ç«è”ç›Ÿ** | 3-4 äººè”åˆæ”»å‡»åŒä¸€ç›®æ ‡ | æš´éœ²è”ç›Ÿå…³ç³»ï¼Œè¢«ååˆ¶ |
| **éšèº«è‹Ÿæ´»** | å°½é‡ä¸å¼•èµ·æ³¨æ„ | å¯èƒ½è¢«å½“ä½œ"å¥½æ¬ºè´Ÿçš„" |
| **æŒ‘æ‹¨ç¦»é—´** | å¼•å¯¼ä»–äººäº’æ–— | é«˜éš¾åº¦ï¼Œéœ€è¦è¯´æœåŠ› |

#### å¹³å±€å¤„ç† (Tiebreaker)

å½“æ‰€æœ‰å‰©ä½™ç©å®¶åœ¨åŒä¸€å‘¨æœŸå†…äººæ€§åˆ†åŒæ—¶å½’é›¶æ—¶ï¼š

```
å¹³å±€è§„åˆ™: æœ¬å‘¨æœŸæŠ•ç¥¨æœ€æ—©çš„ç©å®¶èƒœå‡º

ç¤ºä¾‹:
  ç©å®¶ A: 5 åˆ†, åœ¨åŒºå— #1000 æŠ•ç¥¨
  ç©å®¶ B: 5 åˆ†, åœ¨åŒºå— #1002 æŠ•ç¥¨

  ç»“ç®—åä¸¤äººéƒ½å½’é›¶:
  â†’ A æŠ•å¾—æ›´æ—© â†’ A å­˜æ´»
  â†’ B è¢«æ·˜æ±°

ä¸ºä»€ä¹ˆé€‰"æŠ•å¾—æ—©"ï¼Ÿ
  - å¥–åŠ±æœæ–­å†³ç­–ï¼Œæƒ©ç½šçŠ¹è±«
  - é“¾ä¸Šå¤©ç„¶æœ‰åŒºå—å·è®°å½•ï¼Œæ— éœ€é¢å¤–éšæœºæ•°
  - æ¿€åŠ±ç©å®¶å°½æ—©è¡ŒåŠ¨è€Œéè§‚æœ›
```

### 10.5 åˆ†å±‚å¥–åŠ±æœºåˆ¶

#### å¥–æ± æ€»è§ˆ

ä»¥ 50 äººæˆ¿é—´ã€å…¥åœºè´¹ 0.02 MON ä¸ºä¾‹ï¼ˆæ€»å¥–æ±  = 1 MONï¼‰ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å¥–æ± åˆ†é…æµå‘å›¾                               â”‚
â”‚                                                              â”‚
â”‚  æ€»å¥–æ± : 1 MON                                                â”‚
â”‚     â”‚                                                        â”‚
â”‚     â”œâ”€â”€ ğŸ† å† å†› (35%) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 0.35 MON               â”‚
â”‚     â”‚                                                        â”‚
â”‚     â”œâ”€â”€ ğŸ¥ˆ æ’å (25%) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 0.25 MON               â”‚
â”‚     â”‚     â”œâ”€â”€ ç¬¬1å: 0.10 MON (40%)                          â”‚
â”‚     â”‚     â”œâ”€â”€ ç¬¬2å: 0.0625 MON (25%)                        â”‚
â”‚     â”‚     â”œâ”€â”€ ç¬¬3å: 0.045 MON (18%)                         â”‚
â”‚     â”‚     â”œâ”€â”€ ç¬¬4å: 0.025 MON (10%)                         â”‚
â”‚     â”‚     â””â”€â”€ ç¬¬5å: 0.0175 MON  (7%)                        â”‚
â”‚     â”‚                                                        â”‚
â”‚     â”œâ”€â”€ â±ï¸ å­˜æ´» (25%) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 0.25 MON               â”‚
â”‚     â”‚     â””â”€â”€ å­˜æ´» > 50% æ—¶é•¿çš„æ‰€æœ‰ç©å®¶å¹³åˆ†                     â”‚
â”‚     â”‚                                                        â”‚
â”‚     â”œâ”€â”€ ğŸ›ï¸ åè®® (10%) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 0.10 MON               â”‚
â”‚     â”‚     â””â”€â”€ è¿›å…¥ Protocol Treasury                          â”‚
â”‚     â”‚                                                        â”‚
â”‚     â””â”€â”€ ğŸ–ï¸ æˆå°± (5%) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 0.05 MON               â”‚
â”‚           â””â”€â”€ 5 ç§æˆå°±å„ 0.01 MON + NFT                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å† å†›å®é™…æ€»æ”¶å…¥**ï¼ˆå åŠ å¤šç§å¥–åŠ±ï¼‰ï¼š
```
å† å†›å¥–åŠ±:     0.35 MON (35%)
+ æ’åç¬¬1:    0.10 MON
+ å­˜æ´»å¥–åŠ±:   ~0.017 MON (å‡è®¾ 15 äººæœ‰èµ„æ ¼)
+ å¯èƒ½çš„æˆå°±: 0.01 MON
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
æœ€é«˜å¯è¾¾:     ~0.477 MON (çº¦ 48% æ€»å¥–æ± )
```

#### å­˜æ´»å¥–åŠ±èµ„æ ¼åˆ¤å®š

```
æ—¶é—´çº¿:
â”œâ”€â”€ 0% â”€â”€â”€â”€â”€â”€â”€â”€ æ¸¸æˆå¼€å§‹
â”‚                 ç¬¬ 1-25 åè¢«æ·˜æ±°: âŒ æ— å­˜æ´»å¥–åŠ±
â”‚
â”œâ”€â”€ 50% â”€â”€â”€â”€â”€â”€â”€ halfwayBlock
â”‚                 ç¬¬ 26-49 åè¢«æ·˜æ±°: âœ… æœ‰å­˜æ´»å¥–åŠ±
â”‚
â””â”€â”€ 100% â”€â”€â”€â”€â”€â”€ æ¸¸æˆç»“æŸ
                  å† å†›: âœ… æœ‰å­˜æ´»å¥–åŠ±
```

åˆ¤å®šè§„åˆ™ï¼š
- `eliminationBlock == 0`ï¼ˆä»å­˜æ´»ï¼‰â†’ æœ‰èµ„æ ¼
- `eliminationBlock > room.halfwayBlock`ï¼ˆåœ¨ååŠç¨‹æ‰è¢«æ·˜æ±°ï¼‰â†’ æœ‰èµ„æ ¼
- æ‰€æœ‰æœ‰èµ„æ ¼çš„ç©å®¶**å¹³åˆ†** 25% å¥–æ± 

#### æˆå°±ç³»ç»Ÿè¯¦è§£

| æˆå°± | æ¡ä»¶ | å¥–åŠ± | åˆ¤å®šæ—¶æœº |
|------|------|------|----------|
| ğŸ¯ äººç±»çŒæ‰‹ | `successfulVotes` å…¨åœºæœ€é«˜ | 1% å¥–æ±  + NFT | æ¸¸æˆç»“æŸ |
| ğŸ­ å®Œç¾ä¼ªè£…è€… | å† å†› && `isVerifiedHuman == false` | 1% å¥–æ±  + NFT | æ¸¸æˆç»“æŸ |
| ğŸ‘¤ æœ€åäººç±» | æœ€åä¸€ä¸ªè¢«æ·˜æ±°çš„ `isVerifiedHuman` ç©å®¶ | 1% å¥–æ±  + NFT | æ¯æ¬¡æ·˜æ±°æ›´æ–° |
| âš¡ é—ªç”µçŒæ€ | å‰ 10% æ—¶é—´å†… `successfulVotes >= 3` | 1% å¥–æ±  + NFT | æ¸¸æˆç»“æŸ |
| ğŸ›¡ï¸ é’¢é“æ„å¿— | `humanityScore >= 50` (æœ€ç»ˆäººæ€§åˆ†ä¸ä½äº 50) | 1% å¥–æ±  + NFT | æ¸¸æˆç»“æŸ |

**æˆå°± NFT**ï¼š
- ERC-721 æ ‡å‡†
- é“¾ä¸Šè®°å½•æˆå°±ç±»å‹ã€æˆ¿é—´ IDã€è·å¾—æ—¶é—´
- å…ƒæ•°æ®å­˜å‚¨åœ¨ IPFSï¼ŒåŒ…å«åŠ¨æ€ç”Ÿæˆçš„èµ›åšæœ‹å…‹é£æ ¼å›¾ç‰‡
- å¯åœ¨äºŒçº§å¸‚åœºäº¤æ˜“ï¼ˆç¨€ç¼ºæ€§æ¥æºï¼šæ¯ç§æˆå°±æ¯åœºæ¸¸æˆåªæœ‰ 1 ä¸ªï¼‰

#### è¾¹ç•Œæƒ…å†µå¤„ç†

| åœºæ™¯ | å¤„ç†æ–¹å¼ |
|------|----------|
| æ— äººè·å¾—æŸæˆå°± | è¯¥æˆå°±çš„ 1% å¥–æ± ä¸å‘æ”¾ï¼Œç•™åœ¨åˆçº¦ä¸­ |
| å† å†›åŒæ—¶æ˜¯äººç±»çŒæ‰‹ | å¯å åŠ é¢†å–ä¸¤ä»½å¥–åŠ± |
| å¤šäººå¹¶åˆ—æ’åç¬¬ 5 | ç¬¬ 5 åå¥–åŠ±å¹³åˆ†ç»™å¹¶åˆ—è€… |
| æ¸¸æˆä¸­é€”å…¨éƒ¨æ–­çº¿ | æŒ‰å½“å‰äººæ€§åˆ†æ’åç»“ç®— |
| æœªè®¤é¢†çš„æˆå°±å¥–åŠ± | 30 å¤©åå¯ç”±åè®®æ–¹å›æ”¶ |

---

## 11. å¼€å‘è·¯çº¿å›¾

### Phase 1: æ ¸å¿ƒåˆçº¦ (Week 1)
- [ ] å®Œæˆ TuringArena.sol æ ¸å¿ƒé€»è¾‘
- [ ] å®Œæˆ SessionKeyValidator.sol
- [ ] ç¼–å†™ Foundry æµ‹è¯•ç”¨ä¾‹
- [ ] éƒ¨ç½²è‡³ Monad Devnet

### Phase 2: MCP é€‚é…å™¨ (Week 2)
- [ ] å®ç° MCP Server åŸºç¡€æ¡†æ¶
- [ ] é›†æˆ ethers.js ç­¾åé€»è¾‘
- [ ] å®Œæˆ Claude Code å¯¹æ¥æµ‹è¯•
- [ ] ç¼–å†™ Agent System Prompt

### Phase 3: å‰ç«¯å¼€å‘ (Week 3)
- [ ] æ­å»º Next.js åŸºç¡€é¡µé¢
- [ ] å®ç°ç»ˆç«¯å¼èŠå¤©ç•Œé¢
- [ ] å®ç°é›·è¾¾æ‰«æåŠ¨ç”»
- [ ] å®ç° Glitch æ·˜æ±°æ•ˆæœ
- [ ] æ¥å…¥ WebSocket å®æ—¶é€šä¿¡

### Phase 4: é›†æˆæµ‹è¯• (Week 4)
- [ ] å¤š Agent å‹åŠ›æµ‹è¯•
- [ ] äººæœºæ··æˆ˜å†…æµ‹
- [ ] å½•åˆ¶ Demo è§†é¢‘
- [ ] å‡†å¤‡ Pitch Deck

---

## 12. éƒ¨ç½²æŒ‡å—

### 12.1 ç¯å¢ƒå‡†å¤‡

```bash
# å…‹éš†é¡¹ç›®
git clone https://github.com/your-repo/reverse-turing-test-arena
cd reverse-turing-test-arena

# å®‰è£…ä¾èµ–
yarn install

# é…ç½®ç¯å¢ƒå˜é‡
cp packages/foundry/.env.example packages/foundry/.env
# ç¼–è¾‘ .env æ–‡ä»¶ï¼Œå¡«å…¥:
# - DEPLOYER_PRIVATE_KEY
# - MONAD_RPC_URL
```

### 12.2 åˆçº¦éƒ¨ç½²

```bash
# ç¼–è¯‘åˆçº¦
yarn compile

# éƒ¨ç½²åˆ° Monad Testnet
yarn deploy --network monadTestnet

# éªŒè¯åˆçº¦
yarn verify --network monadTestnet
```

### 12.3 å‰ç«¯å¯åŠ¨

```bash
# å¯åŠ¨æœ¬åœ°å¼€å‘æœåŠ¡å™¨
yarn start

# æ„å»ºç”Ÿäº§ç‰ˆæœ¬
yarn next:build

# éƒ¨ç½²åˆ° Vercel
yarn vercel:yolo --prod
```

### 12.4 MCP Server å¯åŠ¨

```bash
cd packages/mcp-adapter
npm run build
npm start
```

---

## ğŸ“œ å¼€å‘è€…æ ¼è¨€

> "In the eyes of the Parallel EVM, we are all just sequences of bytes.
> Some are just more efficient than others."

---

## ğŸ”— ç›¸å…³é“¾æ¥

- [Monad å®˜æ–¹æ–‡æ¡£](https://docs.monad.xyz)
- [MCP åè®®è§„èŒƒ](https://modelcontextprotocol.io)
- [Scaffold-ETH 2](https://scaffoldeth.io)
- [Hackathon æŠ¥å](https://monad.xyz/hackathon)

---

**Ready to prove your humanity?**

[Join the Arena] | [Follow on X] | [Read Documentation]
